
{% extends "base.html" %}

{% block title %}Еволюція Мов Програмування для Квантових Систем{% endblock %}

{% block css %}
<link rel="stylesheet" href="/static/css/quantum_languages.css">
{% endblock %}


{% block content %}
<div class="processors-container">
 
  <!-- Sidebar Menu -->
  <div id="sidebar-menu" class="sidebar-menu">
    <h3 style="color: #961319; font-style: italic; font-size: 23px; font-weight: 600; text-shadow: 0 0 10px #00d4ff;">Навігація по веб - сторінці квантові мови програмування</h3>
    <ul>
      <li><a href="#section1" class="menu-link">Теоретичні основи</a></li>
      <li><a href="#section2" class="menu-link">Історія: Від QASM до Q#</a></li>
      <li><a href="#section3" class="menu-link">Гібридні парадигми</a></li>
      <li><a href="#section4" class="menu-link">Qiskit 2.0 та Python</a></li>
      <li><a href="#section5" class="menu-link">Q# для хмарних систем</a></li>
      <li><a href="#section6" class="menu-link">Silq: Інтуїтивність</a></li>
      <li><a href="#section7" class="menu-link">Cirq і Google Willow</a></li>
      <li><a href="#section8" class="menu-link">Тренди 2025</a></li>
      <li><a href="#section9" class="menu-link">Майбутнє мов</a></li>
    </ul>
  </div>

  <!-- Modal Context Menu -->
  <div id="modal-menu" class="modal">
    <div class="modal-content">
      <span id="close-modal">&times;</span>
      <h3>Контекстне меню</h3>
      <ul>
        <li><a href="#section1" class="menu-link">Теоретичні основи</a></li>
        <li><a href="#section2" class="menu-link">Історія: Від QASM до Q#</a></li>
        <li><a href="#section3" class="menu-link">Гібридні парадигми</a></li>
        <li><a href="#section4" class="menu-link">Qiskit 2.0 та Python</a></li>
        <li><a href="#section5" class="menu-link">Q# для хмарних систем</a></li>
        <li><a href="#section6" class="menu-link">Silq: Інтуїтивність</a></li>
        <li><a href="#section7" class="menu-link">Cirq і Google Willow</a></li>
        <li><a href="#section8" class="menu-link">Тренди 2025</a></li>
        <li><a href="#section9" class="menu-link">Майбутнє мов</a></li>
      </ul>
    </div>
  </div>

  <!-- Content wrapper -->
  <div class="content-wrapper">
    <!-- Welcome text -->
    <div class="welcome-text">
      <h1 style="color: #921319; font-size: 43px; text-align: center; font-style: italic; font-weight: 700; margin-right: 150px;">Еволюція мов програмування: кодуючи квантовий Всесвіт</h1>
      <br><p style="font-weight: bold;  color: rgb(56, 28, 28); font-size: 29px; text-align: justify; width: 1270px; margin-right: 80px;">Уявіть квантовий комп’ютер як оркестр, де кожен кубіт – інструмент, що грає в суперпозиції. 
       <br> <br>Мови програмування – це партитури, які перетворюють хаос квантових станів у гармонію обчислень, доступну навіть без PhD з фізики.</p>
   
       <img src="https://vajiram-prod.s3.ap-south-1.amazonaws.com/quantum_ed6837d966.webp" style="width: 620px; height: 540px; margin-right: 180px;">
      </div>

    <!-- Розділи -->
    <section id="section1" class="section" style="background-color: #A6B8D3; padding: 20px; margin: 20px 0; border-radius: 10px; animation: fadeInSection 1s ease-in;">
      <h2 style="color: #0a041d; font-weight: 700; font-size: 35px; text-align: left; ">Теоретичні основи: чому квантові мови особливі</h2>
      <p style="line-height: 1.6; font-family: 'Cardo', serif; font-size: 31px; color: #271c2b; animation: colorShiftCardo 5s infinite alternate; text-align: justify;">Квантові алгоритми – це як танець частинок у мікросвіті, де <span style="font-weight: bold; color: rgb(56, 28, 28);">суперпозиція, заплутаність і інтерференція</span> створюють обчислення, недоступні класичним комп’ютерам. 
        <br>Але ці особливості <span style="line-height: 1.6; font-family: 'Cardo', serif; font-size: 31px; color: #211255; font-style: italic; font-weight: 800; animation: colorShiftCardo 5s infinite alternate; text-align: justify;">вимагають унікальних парадигм програмування.</span>
        <br><br> <span class="code-trigger" data-code-id="quantum-paradigm" style="font-weight: bold; color: rgb(56, 28, 28);">Квантові мови</span> повинні підтримувати паралелізм (аналог мультитредінгу), керувати заплутаністю та уникати <span style="font-weight: bold; color: rgb(56, 28, 28);">"вимірювального колапсу"</span>, коли спостереження руйнує суперпозицію. 
        <br>Наприклад, <span style="font-weight: bold; color: rgb(56, 28, 28);">алгоритм Шора</span> для факторизації потребує створення суперпозиції всіх можливих станів, 
        що <span style="line-height: 1.6; font-family: 'Cardo', serif; font-size: 31px; color: #211255; font-style: italic; font-weight: 800; animation: colorShiftCardo 5s infinite alternate; text-align: justify;">неможливо в класичних мовах, як C++ чи Python, без спеціальних абстракцій.</span> 
        
        <p style="line-height: 1.6; font-family: 'Cardo', serif; font-size: 31px; color: #271c2b; animation: colorShiftCardo 5s infinite alternate; text-align: justify;">
          <span style="font-weight: bold; color: #2c3e50;">Квантові мови</span> носять <em style="color: #e74c3c;">ймовірнісний характер</em> та враховують фізичні особливості носіїв <span style="font-weight: bold; color: #2c3e50;">квантової інформації</span>. Основою є <span style="font-weight: bold; color: #2c3e50;">квантові схеми</span>, а послідовне виконання <em style="color: #e74c3c;">квантових інструкцій</em> на базовому рівні реалізовано за допомогою декількох різних типів <span style="font-weight: bold; color: #2c3e50;">квантових вентилів</span> (т.зв. <em style="color: #e74c3c;">гейтів</em>).
        </p>
        
        <p style="line-height: 1.6; font-family: 'Cardo', serif; font-size: 31px; color: #271c2b; animation: colorShiftCardo 5s infinite alternate; text-align: justify;">
          Даний розділ програмування розвивався, починаючи з <span style="font-weight: bold; color: #2c3e50;">низькорівневих мов</span>, де код пишеться та виконується на рівні окремих інструкцій (мова <span style="font-weight: bold; color: #2c3e50;">QASM</span>, – фактично <em style="color: #e74c3c;">асемблер</em>). 
          Сучасні мови та <span style="font-weight: bold; color: #2c3e50;">фреймворки</span>, побудовані на базі мов <span style="font-weight: bold; color: #2c3e50;">Python</span> та <span style="font-weight: bold; color: #2c3e50;">C#</span>, дозволяють абстрагувати взаємодію з <em style="color: #e74c3c;">hardware</em> та навіть писати <span style="font-weight: bold; color: #2c3e50;">квантові нейромережі</span>.
        </p>
        
        <p style="line-height: 1.6; font-family: 'Cardo', serif; font-size: 31px; color: #271c2b; animation: colorShiftCardo 5s infinite alternate; text-align: justify;">
          <span style="font-weight: bold; color: #2c3e50;">Середовища розробки SDK</span>, які включають різноманітні інструменти, – це своєрідний міст між <em style="color: #e74c3c;">кубітами</em> та <span style="font-weight: bold; color: #2c3e50;">високорівневими абстракціями</span>. Величезною перевагою є можливість створювати та запускати <span style="font-weight: bold; color: #2c3e50;">квантові програми</span>, використовуючи <em style="color: #e74c3c;">емулятори</em>.
        </p>
        
        <p style="line-height: 1.6; font-family: 'Cardo', serif; font-size: 31px; color: #271c2b; animation: colorShiftCardo 5s infinite alternate; text-align: justify;">
          Головною властивістю даних <span style="font-weight: bold; color: #2c3e50;">хмарних систем</span> є можливість тестувати програму ніби на справжньому <em style="color: #e74c3c;">квантовому комп’ютері</em>, використовуючи <span style="font-weight: bold; color: #2c3e50;">біти</span> для моделювання поведінки та основних властивостей <em style="color: #e74c3c;">кубітів</em>.
        </p>
        <p style="line-height: 1.6; font-family: 'Cardo', serif; font-size: 31px; color: #271c2b; animation: colorShiftCardo 5s infinite alternate; text-align: justify;">
       
       
        Квантові мови виглядають класичними, але їхня логіка – це міст до мікросвіту. Вони <span style="font-weight: 800;  color: #211255;">також підтримують гібридні обчислення, де класичні CPU керують QPU.</span> 
       </p>
      <br><p style="line-height: 1.6; font-family: 'Cardo', serif; font-size: 31px; color: #211255; animation: colorShiftCardo 5s infinite alternate; text-align: justify;"><ul  style="line-height: 1.6; font-family: 'Cardo', serif; font-size: 31px; color: #211255; font-style: italic; font-weight: 800; animation: colorShiftCardo 5s infinite alternate; text-align: justify;">Про квантові алгоритми та спеціальні мови</span> програмування, такі як:
           <li><span style="font-weight: bold; color: rgb(56, 28, 28);">Twist</span> – це відкрита мова програмування квантових комп’ютерів, яку було розроблено у 2018 році. Вона заснована на Python і використовує відкритий вихідний код. Twist підтримує симуляцію квантових обчислень і їх реалізацію на реальних квантових пристроях;</li>
           <li><span style="font-weight: bold; color: rgb(56, 28, 28);">Qiskit</span> – це відкритий набір інструментів для розробки квантових алгоритмів, створений компанією IBM. Він містить у собі мову програмування Qiskit, яка заснована на Python і дає змогу створювати і симулювати квантові алгоритми, а також реалізовувати їх на реальних квантових пристроях;</li>
           <li><span style="font-weight: bold; color: rgb(56, 28, 28);">Cirq</span> – це відкрита мова програмування квантових обчислень, розроблена компанією Google. Заснована на мові Python і надає інструменти для створення квантових алгоритмів та їх реалізації на реальних квантових пристроях;</li>
           <li><span style="font-weight: bold; color: rgb(56, 28, 28);">Quil</span> – це мова програмування квантових обчислень, розроблена компанією Rigetti. Вона дає змогу створювати квантові алгоритми та реалізовувати їх на реальних квантових пристроях. Quil використовує спеціальний синтаксис, який нагадує асемблерний код;</li>
           <li><span style="font-weight: bold; color: rgb(56, 28, 28);">Microsoft Q#</span> – це мова програмування квантових обчислень, створена компанією Microsoft. Вона заснована на мові C# і дає змогу створювати квантові алгоритми, симулювати їх і реалізовувати на реальних квантових пристроях.</li>
      </ul>
      <p style="line-height: 1.6; font-family: 'Cardo', serif; font-size: 31px; color: #271c2b; animation: colorShiftCardo 5s infinite alternate; text-align: justify;">можна прочитати в наступній публікації: <a href="https://foxminded.ua/kvantove-prohramuvannia/"  style="font-weight: 800;  color: rgb(75, 25, 25); font-size: 26px;" alt="мови програмування для квантових комп'ютерів">Мови програмування для квантових комп'ютерів</a></p>
     
      <img src="https://research.aimultiple.com/wp-content/uploads/2021/04/quantum-languages.jpeg" style="width: 700px; height: 460px;">
    
    </p>
          
    </section>

    <section id="section2" class="section" style="background-color: #A6B8D3; padding: 20px; margin: 20px 0; border-radius: 10px; animation: fadeInSection 1s ease-in;">
      <h2 style="color: #0a041d; font-weight: 700; font-size: 35px; text-align: left;">Історія: від QASM до Q# і Silq</h2>
      <p style="line-height: 1.6; font-family: 'Cardo', serif; font-size: 31px; color: #271c2b; animation: colorShiftCardo 5s infinite alternate; text-align: justify;">Еволюція квантових мов – це як подорож від паперових сувоїв до цифрових бібліотек. 
        
        <br><br>У 2000 році <span style="font-weight: bold; color: rgb(56, 28, 28); font-size: 27px; text-align: justify;">QASM (Quantum Assembly Language)</span> став першим кроком, дозволяючи описувати квантові гейти, як інструкції в асемблері. Це було як писати музику нотами вручну: точно, але складно. 
        
        <img src="https://nap.nationalacademies.org/openbook/25196/xhtml/images/img-170.jpg" style="width: 620px; height: 570px; margin-top: 25px; margin-left: 80px;">

        <br><br>У 2010-х з’явилися високорівневі мови, як <span class="code-trigger" data-code-id="qsharp" style="font-weight: bold; color: rgb(56, 28, 28);">Q#</span> від Microsoft, що інтегрується з Visual Studio і підтримує гібридні обчислення для Azure Quantum. 
        Q# абстрагує гейти в функції, подібно до того, як Python ховає деталі пам’яті.
        
        <br><br>У 2020 році <span style="font-weight: bold; color: rgb(56, 28, 28);">Silq</span> представив "інтуїтивний" підхід, автоматично керуючи допоміжними кубітами, що зменшує помилки розробників на 30% (Quantum Zeitgeist). 
         
        <br><br> У 2025 році <span style="font-weight: bold; color: rgb(56, 28, 28);">Qiskit 2.0</span> і <span style="font-weight: bold; color: rgb(56, 28, 28);">Cirq</span> від Google домінують завдяки інтеграції з Python, роблячи квантове програмування доступним для AI-розробників. <span style="font-weight: bold; color: rgb(56, 28, 28); text-decoration: underline;">Cучасні квантові мови спрощують код до рівня Python, але під капотом керують складними системами з 
          <span style="font-weight: bold; color: rgb(56, 28, 28);">декогеренцією</span> та QECC.</span> 
        
        
         <img src="https://miro.medium.com/v2/resize:fit:1400/0*jAvz6HU6VLNAdEhy" style="width: 550px; height: 500px; margin-left: 0px; margin-top: 25px;">

         <span style="font-weight: bold; color: rgb(56, 28, 28); font-size: 24px; text-align: left;">Наприклад, QASM досі використовується для низькорівневих операцій, але Q# і Silq дозволяють писати алгоритми, як VQE
          , без знання фізичних деталей.</span>
         <br><span style="font-weight: bold;  color: rgb(56, 28, 28); text-decoration: underline; margin-top: 25px; font-size: 27px;">Історично квантові мови еволюціонували від апаратно-орієнтованих до user-friendly, подібно до переходу від Fortran до Java.</span></p>
     
      
    </section>

    <section id="section3" class="section" style="background-color: #A6B8D3; padding: 20px; margin: 20px 0; border-radius: 10px; animation: fadeInSection 1s ease-in;">
      <h2 style="color: #0a041d; font-weight: 700; font-size: 35px; text-align: left;">Гібридні парадигми: класичне + квантове</h2>
      <p style="line-height: 1.6; font-family: 'Cardo', serif; font-size: 31px; color: #271c2b; animation: colorShiftCardo 5s infinite alternate; text-align: justify;">Гібридні парадигми в квантових мовах – це як диригент, що керує оркестром із класичних і квантових інструментів.
         Квантові комп’ютери (QPU) потужні, але обмежені <span style="font-weight: bold; color: rgb(56, 28, 28);">декогеренцією</span> та кількістю кубітів (100–1000 у 2025, MIT).
         <br><br> Тому мови, як <span style="font-weight: bold; color: rgb(56, 28, 28);">Qiskit</span> чи <span style="font-weight: bold; color: rgb(56, 28, 28);">Q#</span>, комбінують класичні CPU/GPU для оптимізації та QPU для квантових обчислень. 
         
         <br><span style="font-weight: 800;  color: #211255;"> Класичний Python-код у Qiskit керує параметрами квантової схеми, подібно до того, як диригент задає ритм, а QPU виконує "соло" суперпозиції.</span>
         <br>Це критично для алгоритмів, як <span class="code-trigger" data-code-id="vqe-hybrid" style="font-weight: bold; color: rgb(56, 28, 28);">VQE</span> (Variational Quantum Eigensolver), де класичний оптимізатор (наприклад, COBYLA) налаштовує квантові параметри. 
        
          <br><br><span style="font-weight: 800;  color: #211255;">Гібридний підхід дозволяє масштабувати обчислення, використовуючи хмарні платформи</span>, як IBM Quantum чи Azure Quantum. 
          Квантові мови виглядають як класичні, але їхня логіка враховує квантову природу, де операції незворотні через вимірювання. 
         </p>
     
      
    </section>

    <section id="section4" class="section" style="background-color: #A6B8D3; padding: 20px; margin: 20px 0; border-radius: 10px; animation: fadeInSection 1s ease-in;">
      <h2 style="color: #0a041d; font-weight: 700; font-size: 35px; text-align: left;">Qiskit 2.0 та Python: демократизація квантового коду</h2>
      <p style="line-height: 1.6; font-family: 'Cardo', serif; font-size: 31px; color: #271c2b; animation: colorShiftCardo 5s infinite alternate; text-align: justify;">Qiskit 2.0</span> у 2025 році – це як космічний корабель, що робить квантове програмування доступним для Python-розробників. 
        
        <br><br><span style="font-weight: bold;  color: rgb(56, 28, 28);">Python – найпопулярніша мова для AI та ML, і Qiskit використовує її синтаксис,</span> щоб абстрагувати складність квантових гейтів. 
        
        <br><br>Замість опису низькорівневих операцій, як у QASM, ви пишете код, схожий на TensorFlow, створюючи <span class="code-trigger" data-code-id="qiskit-circuit" style="font-weight: bold; color: rgb(56, 28, 28);">квантові схеми</span> з кількох рядків. 
        
        <br><br> <span style="font-weight: bold;  color: rgb(56, 28, 28);">Qiskit підтримує симуляцію на класичних комп’ютерах і доступ до реальних QPU, як IBM Loon, через хмару.</span> 
        <br>Це дозволяє тестувати алгоритми, як Shor чи Grover, без фізичного доступу до квантового апаратного забезпечення. 
        <br><br>У 2025 році Qiskit 2.0 інтегрується з QECC, зменшуючи помилки на 30% (NIST), і підтримує гібридні алгоритми, як VQE, для задач, як моделювання молекул.
        <br>Qiskit виглядає як Python-бібліотека, але керує квантовим хаосом. За Quantum Zeitgeist, <span style="font-weight: bold;  color: rgb(56, 28, 28);">50% квантових розробників використовують Qiskit через його простоту та спільноту.</span></p>
         
        <details>
          <summary>Наприклад, для вирішення задачі оптимізації портфеля фінансових активів</summary>
          <p style="font-size: 23px; font-style: italic; font-weight: 800; color: rgb(8, 8, 20);">
            Це класична задача фінансової математики, де потрібно вибрати активи для максимізації прибутку при мінімальному ризику, з урахуванням бюджету. 
           
            <br><br><span style="font-weight: bold; color: rgb(56, 28, 28);"> Квантова парадигма</span> використовується, оскільки класичні методи (наприклад, для великих наборів даних) є обчислювально складними, 
            а <span style="font-weight: bold; color: rgb(56, 28, 28);">квантові алгоритми, як QAOA (Quantum Approximate Optimization Algorithm)</span>, 
            можуть потенційно <span style="font-weight: bold; color: rgb(56, 28, 28);">знайти оптимальні рішення швидше</span> завдяки суперпозиції та заплутаності. 
            
            <br><br><span style="font-weight: bold; color: rgb(56, 28, 28);"> Qiskit</span> обрано як фреймворк, бо це відкрита платформа від IBM для квантового програмування, яка <span style="font-weight: bold; color: rgb(56, 28, 28);">інтегрує інструменти для моделювання, оптимізації та симуляції квантових систем</span>, з підтримкою реальних квантових пристроїв. 
            <br>Ось лаконічний і зрозумілий опис процесу з методологічним підходом:<br><br>
        
            <strong>1. Визначення допоміжної функції для виведення результатів</strong><br>
            Створюємо функцію <code>print_result</code>, яка форматує результати оптимізації (вибрані активи, значення цільової функції, ймовірності).
            <br> Це полегшує аналіз результатів, виводячи їх у зрозумілому вигляді.<br><br>
        
            <strong>2. Налаштування генератора випадкових чисел для відтворюваності</strong><br>
            Встановлюємо випадкове зерно (<code>random_seed = 1234</code>) для генерації даних, щоб результати були однаковими при повторних запусках. 
            <br>Використовується для генерації випадкових значень фінансових активів (часових рядів прибутків), але це лише для моделювання тестових даних, а не реальних ринкових.<br><br>
        
            <strong>3. Визначення параметрів задачі оптимізації портфеля</strong><br>
            Задаємо кількість активів (<code>num_assets = 4</code>), яка дорівнює кількості кубітів. 
            <br><br>Маються на увазі логічні кубіти, оскільки кожен актив представлений одним кубітом у квантовій моделі для бінарного вибору (включити/не включити актив у портфель).<br><br>
        
            <strong>4. Генерація даних: очікувані прибутки та матриця коваріації</strong><br>
            Використовуємо <code>RandomDataProvider</code> для створення синтетичних часових рядів прибутків активів. 
            <br><br>Це дійсно створює математичну модель, де <code>mu</code> — вектор очікуваних прибутків, а <code>sigma</code> — матриця коваріації, що відображає волатильність і кореляцію між активами.<br><br>
        
            <strong>5. Візуалізація матриці коваріації (опціонально)</strong><br>
            Відображаємо матрицю <code>sigma</code> як теплову карту, щоб побачити кореляцію між активами (наскільки їхні прибутки рухаються разом).
            <br> Висока кореляція означає, що активи поводяться схоже, що може збільшити ризик портфеля.<br><br>
        
            <strong>6. Встановлення параметрів оптимізації</strong><br>
            Задаємо фактори ризику (<code>q = 0.5</code>), бюджет (<code>budget = num_assets // 2</code>) і штраф за порушення бюджету (<code>penalty = num_assets</code>). 
            <br><br>Вищезазначені параметри балансують між максимізацією прибутку та мінімізацією ризику, враховуючи обмеження на кількість активів у портфелі.<br><br>
        
            <strong>7. Створення об’єкта задачі оптимізації портфеля</strong><br>
            Формуємо об’єкт <code>PortfolioOptimization</code>, який є високорівневою абстракцією задачі. 
            <br><br>Об’єкт інкапсулює всі параметри (прибутки, коваріацію, бюджет), готуючи задачу до подальшого перетворення.<br><br>
        
            <strong>8. Перетворення задачі у форму квадратичної програми</strong><br>
            Переводимо задачу в формат квадратичної програми (Quadratic Program), який сумісний із квантовими алгоритмами, такими як QAOA.
            <br><br>Це математичне формулювання, де цільова функція та обмеження виражені як квадратичні рівняння.<br><br>
        
            <strong>9. Розв’язання задачі за допомогою QAOA</strong><br>
            Використовуємо алгоритм QAOA з оптимізатором COBYLA та симулятором (<code>Sampler</code>). 
            <br> QAOA ітерує через квантові стани, щоб знайти оптимальний розв’язок, <span style="color:#0a041d; text-decoration: underline;">використовуючи кілька повторень (<code>reps=3</code>) для покращення точності</span>.<br><br>
        
            <img src="https://image.slideserve.com/495121/quantum-computers-and-probability-l.jpg" style="width: 480px; height: 360px;" alt="Quantum Computers">

            <strong>10. Виведення результатів</strong><br>
            Викликаємо функцію <code>print_result</code>, щоб показати оптимальний набір активів, значення цільової функції (баланс між прибутком і ризиком) та ймовірності можливих рішень, отриманих із квантового стану.
          </p>
        </details>
         
     <div id="qiskit-circuit-code" class="code-block" style="font-size: 23px; font-weight: 800; color:#003366;">
      <pre>
          # Імпорт необхідних бібліотек для квантової оптимізації портфеля
          from qiskit.circuit.library import TwoLocal
          from qiskit.result import QuasiDistribution
          from qiskit_aer.primitives import Sampler
          from qiskit_algorithms import NumPyMinimumEigensolver, QAOA, SamplingVQE
          from qiskit_algorithms.optimizers import COBYLA
          from qiskit_finance.applications.optimization import PortfolioOptimization
          from qiskit_finance.data_providers import RandomDataProvider
          from qiskit_optimization.algorithms import MinimumEigenOptimizer
          import numpy as np
          import matplotlib.pyplot as plt
          import datetime
          from qiskit.utils import algorithm_globals
          
          # Визначення допоміжної функції для виведення результатів у зручному форматі
          def print_result(result):
              """
              Виводить результат оптимізації, включаючи оптимальний вибір, значення 
              та розподіл ймовірностей розв'язків.
              """
              selection = result.x
              value = result.fval
              print("Optimal: selection {}, value {:.4f}".format(selection, value))
          
              eigenstate = result.min_eigen_solver_result.eigenstate
              probabilities = (
                  eigenstate.binary_probabilities()
                  if isinstance(eigenstate, QuasiDistribution)
                  else {k: np.abs(v) ** 2 for k, v in eigenstate.to_dict().items()}
              )
              print("\n----------------- Full result ---------------------")
              print("selection\tvalue\t\tprobability")
              print("---------------------------------------------------")
              probabilities = sorted(probabilities.items(), key=lambda x: x[1], reverse=True)
          
              for k, v in probabilities:
                  x = np.array([int(i) for i in list(reversed(k))])
                  value = portfolio.to_quadratic_program().objective.evaluate(x)
                  print("%10s\t%.4f\t\t%.4f" % (x, value, v))
          
          # Встановлення випадкового зерна для відтворюваності та визначення параметрів задачі
          algorithm_globals.random_seed = 1234
          
          # Визначення параметрів задачі оптимізації портфеля
          num_assets = 4  # Кількість активів (дорівнює кількості кубітів)
          seed = 123      # Випадкове зерно для генерації даних
          
          # Генерація очікуваних прибутків та матриці коваріації з випадкових часових рядів даних
          stocks = [("TICKER%s" % i) for i in range(num_assets)]
          data = RandomDataProvider(
              tickers=stocks,
              start=datetime.datetime(2016, 1, 1),
              end=datetime.datetime(2016, 1, 30),
              seed=seed,
          )
          data.run()
          mu = data.get_period_return_mean_vector()      # Вектор очікуваних прибутків
          sigma = data.get_period_return_covariance_matrix()  # Матриця коваріації
          
          # Опціонально: Візуалізація матриці коваріації
          plt.imshow(sigma, interpolation="nearest")
          plt.show()
          
          # Встановлення параметрів оптимізації
          q = 0.5              # Фактор ризику (контролює апетит до ризику)
          budget = num_assets // 2  # Обмеження бюджету (кількість активів для вибору)
          penalty = num_assets      # Параметр штрафу за порушення обмеження бюджету
          
          # Створення екземпляра задачі оптимізації портфеля
          portfolio = PortfolioOptimization(
              expected_returns=mu, 
              covariances=sigma, 
              risk_factor=q, 
              budget=budget
          )
          
          # Перетворення на форму квадратичної програми
          qp = portfolio.to_quadratic_program()
          print(qp)
          
          # Розв'язання за допомогою QAOA (Quantum Approximate Optimization Algorithm)
          # Налаштування оптимізатора
          cobyla = COBYLA()
          cobyla.set_options(maxiter=250)  # Максимальна кількість ітерацій
          
          # Створення екземпляра QAOA з вказаними повтореннями
          qaoa_mes = QAOA(sampler=Sampler(), optimizer=cobyla, reps=3)
          
          # Обгортка QAOA з MinimumEigenOptimizer для розв'язання квадратичної програми
          qaoa = MinimumEigenOptimizer(qaoa_mes)
          
          # Розв'язання задачі оптимізації портфеля
          result = qaoa.solve(qp)
          
          # Виведення результатів
          print_result(result)
     </pre>
   </div>

      
      <table style="width: 100%; border-collapse: collapse; margin: 20px 0; color: #050d55;">
        <thead>
          <tr style="background: #003366;">
            <th style="padding: 10px; border: 1px solid #4a90e2;">Фреймворк</th>
            <th style="padding: 10px; border: 1px solid #4a90e2;">Розробник</th>
            <th style="padding: 10px; border: 1px solid #4a90e2;">Особливості</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td style="padding: 10px; border: 1px solid #4a90e2;">Qiskit</td>
            <td style="padding: 10px; border: 1px solid #4a90e2;">IBM</td>
            <td style="padding: 10px; border: 1px solid #4a90e2;">Python, QECC, хмара</td>
          </tr>
          <tr>
            <td style="padding: 10px; border: 1px solid #4a90e2;">Q#</td>
            <td style="padding: 10px; border: 1px solid #4a90e2;">Microsoft</td>
            <td style="padding: 10px; border: 1px solid #4a90e2;">Гібридні, Azure</td>
          </tr>
          <tr>
            <td style="padding: 10px; border: 1px solid #4a90e2;">Silq</td>
            <td style="padding: 10px; border: 1px solid #4a90e2;">ETH Zurich</td>
            <td style="padding: 10px; border: 1px solid #4a90e2;">Інтуїтивність, безпека</td>
          </tr>
        </tbody>
      </table>

      <p><a href="https://www.ibm.com/quantum/qiskit" style="font-weight: 800;  color: rgb(56, 28, 28); font-size: 24px; font-style: italic;" target="_blank">Qiskit documentation</a></p>
    </section>

    <section id="section5" class="section" style="background-color: #A6B8D3; padding: 20px; margin: 20px 0; border-radius: 10px; animation: fadeInSection 1s ease-in;">
      <h2 style="color: #0a041d; font-weight: 700; font-size: 35px; text-align: left;">Q# для хмарних квантових систем</h2>
      <p style="line-height: 1.6; font-family: 'Cardo', serif; font-size: 31px; color: #271c2b; animation: colorShiftCardo 5s infinite alternate; text-align: justify;">Q#</span> від Microsoft – це як космічна станція, що об’єднує розробників у <span style="font-weight: bold;  color: rgb(56, 28, 28);">хмарному просторі Azure Quantum.</span> 
        
        <br><br>Створена для гібридних обчислень, Q# дозволяє писати квантові програми, що виконуються на QPU чи симуляторах, інтегруючись із C# чи Python. 
        
        <br>Ви пишете код, схожий на класичний, але він керує <span style="font-weight: bold; color: rgb(56, 28, 28);">заплутаністю кубітів</span>, як диригент оркестру. 
        
        <br><br>Q# підтримує алгоритми, як <span class="code-trigger" data-code-id="qsharp-grover" style="font-weight: bold; color: rgb(56, 28, 28);">Grover</span>, для пошуку в неструктурованих базах даних із квадратичним прискоренням. 
        
       <br><br> <span style="font-weight: bold;  color: rgb(56, 28, 28);">У 2025 році Q# використовується в 30% хмарних квантових проєктів (Moody’s), завдяки інтеграції з Azure,</span> що забезпечує доступ до QPU від Quantinuum і IonQ.
        
       <br><br> <span style="font-weight: bold;  color: rgb(56, 28, 28);">Q# виглядає як C#, але його функції, як H чи CNOT, відображають квантову природу.</span>  
       <br>Q# вимагає вивчення <span style="font-weight: bold;  color: rgb(56, 28, 28);">нової парадигми, але бібліотеки, як Quantum Development Kit</span>, спрощують це.
         
         <br><br>Наприклад, Q# дозволяє створювати гібридні алгоритми для оптимізації в логістиці, де класичний код оптимізує параметри, а квантовий виконує обчислення.</p>
         <details>
          <summary>Наприклад, для вирішення задачі оптимізації маршруту в логістиці (TSP)</summary>
          <p style="font-size: 23px; font-style: italic; font-weight: 800; color: rgb(8, 8, 20);">
            Давайте розберемося крок за кроком: задача TSP (Travelling Salesman Problem, або проблема комівояжера) — це <span style="font-weight: bold;  color: rgb(56, 28, 28);">класичний приклад у логістиці, де потрібно знайти найкоротший маршрут, що проходить через усі вказані міста точно один раз і повертається до стартового пункту, мінімізуючи загальну відстань чи час</span>.
            
            <br><br>Це корисно для реальних сценаріїв, як планування доставок чи маршрутів транспорту. 
            

            <br><br>Чому тут застосовується <span style="font-weight: bold;  color: rgb(56, 28, 28);">квантовий підхід?</span> Класичні алгоритми для великих наборів міст <span style="font-weight: bold;  color: rgb(56, 28, 28);">вимагають величезних обчислень</span> (вона належить до класу NP-складних задач), тому квантові методи, такі як QAOA 
            (Quantum Approximate Optimization Algorithm — квантовий алгоритм наближеної оптимізації), можуть допомогти знайти хороші наближені рішення швидше.
            <br> QAOA використовує ключові квантові принципи: суперпозицію (коли кубіти — базові одиниці квантової інформації — перебувають у кількох станах одночасно, дозволяючи паралельний пошук) та заплутаність (зв'язок між кубітами, що посилює обчислювальну потужність). 
            
            <br><br>Мова <span style="font-weight: bold;  color: rgb(56, 28, 28);">Q# від Microsoft обрана</span>, бо це спеціалізований інструмент для квантового програмування в <span style="font-weight: bold;  color: rgb(56, 28, 28); text-decoration: underline;">Quantum Development Kit</span>: вона дозволяє легко працювати з кубітами, симулювати алгоритми та запускати їх на реальних квантових комп'ютерах.
            <br><br> Важливий коментар: <span style="font-weight: bold;  color: rgb(56, 28, 28);">у цій програмі нейромережа не використовується.</span> 
           
            <br><br>QAOA — це не нейронна мережа, а <span style="font-weight: bold;  color: rgb(56, 28, 28); text-decoration: underline;">варіаційний квантовий алгоритм, натхненний ідеями оптимізації</span>, <span style="font-weight: bold;  color: rgb(56, 28, 28);"></span>але без шарів нейронів чи навчання на даних</span>; 
            <br>він <span style="font-weight: bold;  color: rgb(56, 28, 28);">базується на квантовій механіці та класичній оптимізації параметрів</span>. Ось лаконічний і зрозумілий опис процесу з методологічним підходом:<br><br>
        
            <strong>1. Визначення основної операції для застосування QAOA</strong><br>
            Створюємо операцію <code>ApplyQAOA</code>, яка реалізує алгоритм QAOA для задачі, сформульованої як QUBO (Quadratic Unconstrained Binary Optimization — квадратична бінарна оптимізація без обмежень, де рішення представлені 0/1 змінними, наприклад, для вибору шляхів у TSP). 
            <br>Вона починається з створення суперпозиції (за допомогою Hadamard-гейтів, що ставлять кубіти в рівномірний розподіл станів) і чергують "cost-гамільтоніан" (енергія проблеми, що оцінює якість рішення) та 
            <br>"mixer-гамільтоніан" (для "перемішування" станів і пошуку кращих варіантів).<br><br>
        
            <strong>2. Реалізація cost-гамільтоніана (модель Ising для QUBO)</strong><br>
            <br>Операція <code>ApplyInstanceHamiltonian</code> моделює <span style="font-weight: bold;  color: rgb(56, 28, 28);">cost-гамільтоніан — математичний оператор, що описує "вартість" або енергію системи</span> в квантовій механіці. 
            
            <br><br>Вона використовує модель Ising (фізична модель магнітних спінів, де бінарні змінні мапуються на "вгору/вниз" стани). 
            <br>Застосовує фазові зсуви (гейт Rz для лінійних частин, що впливають на окремі кубіти) та взаємодії (симуляція ZZ-гейтів через Controlled Rz для пар кубітів, що враховують зв'язки між змінними), з параметром "часу еволюції" 
            (гамма — кут обертання для контролю глибини).<br><br>
        
            <strong>3. Реалізація mixer-гамільтоніана</strong><br>
            Операція <code>ApplyDriverHamiltonian</code> створює <span style="font-weight: bold;  color: rgb(56, 28, 28);">mixer-гамільтоніан — стандартний для QAOA, що складається з суми X-гейтів (операторів,</span> що "перевертають" стани кубітів). 
            <br>Використовує гейт Rx (ротація навколо X-осі) з параметром бетта, дозволяючи системі "досліджувати" різні комбінації станів і уникати локальних мінімумів.<br><br>
        
            <strong>4. Оцінка ймовірності конкретного стану</strong><br>
            Операція <code>MeasureProbabilityForState</code> розраховує, наскільки ймовірним є певний стан (бінарний вектор, що кодує маршрут у TSP, наприклад, послідовність відвідування міст). 
            <br>Використовує функцію EstimateFrequency для статистичної оцінки на основі багатьох вимірювань (квантові стани колапсують при вимірюванні, тому потрібні повторення для точності). 
            <br><br>Це ключова квантова специфіка: результати — ймовірнісні, а не детерміновані.<br><br>
        
            <strong>5. Перевірка стану реєстру кубітів</strong><br>
            Допоміжна операція <code>MeasureRegisterIsInState</code> вимірює весь реєстр кубітів (за допомогою MultiM — множинного вимірювання, що дає результати для кожного кубіту) і порівнює з цільовим станом. 
            
            <br><br>Повертає Zero, якщо збігається (дійсний маршрут без повторів), або One інакше — це фільтрує недійсні рішення в TSP.<br><br>
        
            <strong>6. Приклад запуску для логістичної задачі (TSP для 3 міст)</strong><br>
            Операція <code>SolveLogisticsTSP</code> налаштовує конкретний приклад: TSP з 3 містами, кодованими 6 кубітами (бінарне представлення позицій у циклі). 
            <br>Визначає ваги (лінійні коефіцієнти h_i для окремих змінних), з'єднання (квадратичні J_ij для взаємодій, у верхньому трикутнику матриці, що враховує витрати між містами), параметри бетта/гамма (оптимізовані класично для кращої точності).<br><br>
        
            <strong>7. Оцінка ймовірностей дійсних станів</strong><br>
            Визначає дійсні стани (дозволені цикли в TSP, наприклад, повні маршрути без повторів) і обчислює їх ймовірності за допомогою <code>MeasureProbabilityForState</code>, використовуючи задану кількість вимірювань (1024 "пострілів" — повторів симуляції для статистичної надійності).<br><br>
        
            <strong>8. Обчислення ймовірності недійсних станів</strong><br>
            Розраховує залишкову ймовірність (otherProb) для всіх недійсних станів, віднімаючи суму ймовірностей дійсних — це показує, наскільки добре QAOA уникає помилкових рішень і оцінює загальну ефективність алгоритму.<br><br>
        
            <strong>9. Повернення результатів</strong><br>
            <span style="font-weight: bold;  color: rgb(56, 28, 28); text-decoration: underline;">Повертає масив ймовірностей для дійсних станів та недійсних, що дозволяє подальшу класичну обробку (наприклад, вибір найкращого маршруту з найвищою ймовірністю 
              або найнижчою "енергією" — вартістю шляху)</span>.<br><br>
        
            <strong>10. Загальна інтеграція</strong><br>
            Уся програма розміщена в просторі імен (namespace) LogisticsOptimization, об'єднуючи операції для симуляції QAOA на Q#.
            <br><br> Це наближено до реальних квантових програм: результати можна адаптувати для більших логістичних задач, як оптимізація ланцюгів постачань, з потенціалом для масштабування на потужніші квантові системи.
          </p>
        </details>
     
         <div id="qsharp-grover-code" class="code-block" style="font-size: 23px; font-weight: 800; color:#003366;">
        <pre>
          namespace LogisticsOptimization {

            open Microsoft.Quantum.Intrinsic;
            open Microsoft.Quantum.Measurement;
            open Microsoft.Quantum.Arrays;
            open Microsoft.Quantum.Math;
            open Microsoft.Quantum.Convert;
            open Microsoft.Quantum.Diagnostics;
        
            // Основна операція для застосування QAOA до задачі оптимізації маршрутів (наприклад, TSP як QUBO)
            operation ApplyQAOA(
                qubits : Qubit[],           // Кубіти для представлення змінних
                numSegments : Int,          // Кількість шарів QAOA (p)
                weights : Double[],         // Вагові коефіцієнти для лінійних членів (h_i в Ising)
                couplings : Double[],       // Коефіцієнти взаємодій (J_ij в Ising)
                timeX : Double[],           // Параметри бетта для міксеру (driver Hamiltonian)
                timeZ : Double[]            // Параметри гамма для гамільтоніана проблеми (cost Hamiltonian)
            ) : Unit {
                // Підготовка рівномірної суперпозиції: застосування Hadamard до всіх кубітів
                ApplyToEach(H, qubits);
        
                // Застосування шарів QAOA: чергування cost та mixer гамільтоніанів
                for (tz, tx) in Zipped(timeZ, timeX) {
                    // Застосування еволюції cost гамільтоніана: Exp(-i * tz * H_C)
                    ApplyInstanceHamiltonian(Length(qubits), tz, weights, couplings, qubits);
                    // Застосування еволюції mixer гамільтоніана: Exp(-i * tx * H_M)
                    ApplyDriverHamiltonian(tx, qubits);
                }
            }
        
            // Операція для застосування cost гамільтоніана (Ising модель для QUBO)
            operation ApplyInstanceHamiltonian(
                nQubits : Int,              // Кількість кубітів
                time : Double,              // Час еволюції (гамма)
                weights : Double[],         // Лінійні коефіцієнти
                couplings : Double[],       // Квадратичні коефіцієнти
                qubits : Qubit[]            // Регістр кубітів
            ) : Unit is Adj + Ctl {
                // Застосування фазових зсувів для лінійних членів (Z на кожному кубіті)
                for i in 0..nQubits-1 {
                    Rz(2.0 * time * weights[i], qubits[i]);
                }
                // Застосування для квадратичних членів (ZZ взаємодії)
                mutable idx = 0;
                for i in 0..nQubits-2 {
                    for j in i+1..nQubits-1 {
                        let angle = 2.0 * time * couplings[idx];
                        Controlled Rz([qubits[i]], (angle, qubits[j]));  // Симуляція ZZ через CNOT + Rz + CNOT, але спрощено
                        set idx += 1;
                    }
                }
            }
        
            // Операція для застосування mixer гамільтоніана (стандартний для QAOA: сума X на кубітах)
            operation ApplyDriverHamiltonian(
                time : Double,              // Час еволюції (бетта)
                qubits : Qubit[]            // Регістр кубітів
            ) : Unit is Adj + Ctl {
                // Застосування Rx на кожен кубіт для еволюції під H_M = sum X_i
                ApplyToEach(Rx(2.0 * time, _), qubits);
            }
        
            // Операція для оцінки ймовірності конкретного стану
            operation MeasureProbabilityForState(
                state : Result[],           // Цільовий стан (бінарний вектор)
                numSegments : Int,          // Кількість шарів
                weights : Double[],         // Вагові коефіцієнти
                couplings : Double[],       // Коефіцієнти взаємодій
                timeX : Double[],           // Параметри бетта
                timeZ : Double[],           // Параметри гамма
                numMeasurements : Int       // Кількість вимірювань для оцінки
            ) : Double {
                // Використання EstimateFrequency для оцінки частоти стану
                return EstimateFrequency(
                    ApplyQAOA(_, numSegments, weights, couplings, timeX, timeZ),
                    MeasureRegisterIsInState(_, state),
                    Length(state),
                    numMeasurements
                );
            }
        
            // Допоміжна операція для перевірки, чи реєстр у заданому стані
            operation MeasureRegisterIsInState(
                register : Qubit[],         // Регістр кубітів
                state : Result[]            // Цільовий стан
            ) : Result {
                let results = MultiM(register);  // Вимірювання всіх кубітів
                if (All(EqualR, Zipped(results, state))) {
                    return Zero;  // Збігається
                } else {
                    return One;   // Не збігається
                }
            }
        
            // Приклад запуску для логістичної задачі: оптимізація маршруту (TSP для 3 міст як QUBO)
            // Тут: Дозволені стани для циклу (наприклад, для 6 кубітів у TSP кодуванні)
            operation SolveLogisticsTSP() : Double[] {
                // Визначення параметрів для прикладу TSP (спрощений QUBO)
                let numQubits = 6;  // Для 3 міст у бінарному кодуванні
                let numSegments = 2;  // p=2
                let weights = [1.0, 1.0, 1.0, 1.0, 1.0, 1.0];  // Прикладні ваги (h_i)
                let couplings = [0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5];  // J_ij (верхній трикутник)
                let timeX = [PI() / 4.0, PI() / 4.0];  // Бетта (оптимізовані класично)
                let timeZ = [PI() / 2.0, PI() / 2.0];  // Гамма
                let numMeasurements = 1024;  // Кількість пострілів
        
                // Дозволені стани для TSP (приклад: цикли)
                let state1 = [One, One, One, One, Zero, Zero];
                let state2 = [Zero, One, Zero, One, One, One];
                let state3 = [One, Zero, One, Zero, One, One];
                let states = [state1, state2, state3];
        
                mutable result = new Double[Length(states) + 1];
                mutable otherProb = 1.0;  // Ймовірність недійсних станів
        
                // Оцінка ймовірностей для кожного дійсного стану
                for (index, state) in Enumerated(states) {
                    let prob = MeasureProbabilityForState(state, numSegments, weights, couplings, timeX, timeZ, numMeasurements);
                    set result w/= index <- prob;
                    set otherProb -= prob;
                }
        
                set result w/= Length(states) <- otherProb;
        
                // Повернення ймовірностей (для подальшої оцінки енергії класично)
                return result;
            }
        }
        </pre>
      </div>
      <p><a href="https://learn.microsoft.com/en-us/azure/quantum/qsharp-overview" style="font-weight: 800;  color: rgb(56, 28, 28); font-size: 24px; font-style: italic;" target="_blank">Microsoft Q# Documentation</a></p>
    </section>

    <section id="section6" class="section" style="background-color: #A6B8D3; padding: 20px; margin: 20px 0; border-radius: 10px; animation: fadeInSection 1s ease-in;">
      <h2 style="color: #0a041d; font-weight: 700; font-size: 35px; text-align: left;">Silq: інтуїтивність у квантовому коді</h2>
      <p style="line-height: 1.6; font-family: 'Cardo', serif; font-size: 31px; color: #271c2b; animation: colorShiftCardo 5s infinite alternate; text-align: justify;">Silq</span>, розроблений ETH Zurich. У 2025 році Silq оновлено для автоматичного керування допоміжними кубітами, що зменшує помилки на 40% порівняно з QASM (Quantum Zeitgeist). 
        
        <br><br>У класичних квантових мовах, як QASM, розробник вручну очищає тимчасові кубіти, що призводить до помилок. Silq робить це автоматично, подібно до garbage collection у Java. 
        
        <br>Це дозволяє писати <span class="code-trigger" data-code-id="silq-circuit" style="font-weight: bold; color: rgb(56, 28, 28);">чисті схеми</span>, зосереджуючись на логіці, а не на квантовій механіці.
        <br><br> Silq ідеально підходить для алгоритмів, як QAOA, для оптимізації комбінаторних задач. 
         
        <br><br> У 2025 році Silq використовується в 20% академічних проєктів, але його інтеграція з промисловими QPU, як IBM Loon, ще обмежена. 
        
        <p style="font-size: 23px; color: black; font-style: italic;">
          <strong>Задача: Використання алгоритму VQE для знаходження енергії зв’язку молекули води (H₂O)</strong><br>
          <br> Алгоритм VQE (Variational Quantum Eigensolver) застосовується для знаходження найнижчої енергії (основного стану) молекули води, що є ключовим для розуміння її хімічних властивостей. 
          <br><br>  VQE використовує гібридний квантовий-класичний підхід: квантовий комп’ютер обчислює енергію гамільтоніана для пробного стану, а класичний оптимізатор коригує параметри для мінімізації енергії.
          <br>  У мові <code>Silq</code> код спрощується завдяки автоматичному очищенню квантової пам’яті.
          <br><br>  Молекула H₂O є фундаментальною для хімії та екології, а її енергія зв’язку впливає на процеси, як-от електроліз для виробництва водню, що має застосування в зеленій енергетиці. 
          <br>  Нижче наведено приклад коду для VQE на <code>Silq</code>, який моделює енергію зв’язку H₂O:
      </p>
      
      <pre style="font-size: 23px; color: black; font-style: italic; background-color: #f5f5f5; padding: 10px;">
      <code>
      // Імпорт базового модуля Silq
      import silq;
      
      // Спрощений гамільтоніан для H₂O
      const c0 = -75.0; const c1 = 0.15; const c2 = 0.15; const c3 = 0.12;
      const c4 = 0.20; const c5 = 0.10; const c6 = 0.08;
      
      // Підготовка анзацу
      def prepare_ansatz(theta: float, phi: float, qubits: qbit[3]) : qbit[3] {
          qubits[0] := Ry(theta, qubits[0]);
          qubits[1] := Ry(theta, qubits[1]);
          qubits[2] := Ry(phi, qubits[2]);
          qubits := CNOT(qubits[0], qubits[1]);
          qubits := CNOT(qubits[1], qubits[2]);
          return qubits;
      }
      
      // Вимірювання енергії
      def measure_energy(qubits: qbit[3]) : float {
          let z0 = measure_expectation(qubits[0], Z);
          let z1 = measure_expectation(qubits[1], Z);
          let z2 = measure_expectation(qubits[2], Z);
          let z0z1 = measure_expectation(qubits, Z_0*Z_1);
          let x0x1 = measure_expectation(qubits, X_0*X_1);
          let y1y2 = measure_expectation(qubits, Y_1*Y_2);
          let energy = c0 + c1*z0 + c2*z1 + c3*z2 + c4*z0z1 + c5*x0x1 + c6*y1y2;
          return energy;
      }
      
      // Оптимізація енергії
      def optimize_energy(n_iterations: uint) : float {
          let qubits: qbit[3] = qbit[3]:0;
          let mut theta = 0.0; let mut phi = 0.0;
          let mut min_energy = 1000.0;
          for i in 0..n_iterations-1 {
              let trial_qubits = prepare_ansatz(theta, phi, qubits);
              let energy = measure_energy(trial_qubits);
              if energy < min_energy {
                  min_energy = energy;
              } else {
                  theta = theta - 0.05; phi = phi - 0.05;
              }
              theta = theta + 0.05; phi = phi + 0.05;
          }
          return min_energy;
      }
      
      // Точка входу
      def main() {
          let n_iterations = 20;
          let ground_energy = optimize_energy(n_iterations);
          print("Ground state energy of H2O: ", ground_energy);
      }
      </code>
      </pre>
      
      <p style="font-size: 23px; color: black; font-style: italic;">
          <strong>Пояснення:</strong> Код моделює енергію зв’язку H₂O (~-76.4 Ха), використовуючи три кубіти для спрощених орбіталей. Гамільтоніан розкладено на оператори Паулі (<code>Z</code>, <code>X</code>, <code>Y</code>). Анзац створюється обертаннями <code>Ry</code> та ентанглементом через <code>CNOT</code>. Silq автоматично керує квантовими ресурсами, зменшуючи помилки. 
          <br><br>Цей підхід може застосовуватися для моделювання хімічних реакцій, наприклад, у розробці каталізаторів для електролізу води.
      </p>
      <p style="font-size: 23px; color: black; font-style: italic;">
        <strong>Коментарі до коду</strong>
    </p>
    <ol style="font-size: 23px; color: black; font-style: italic;">
        <li><strong>Гамільтоніан:</strong> Спрощуємо гамільтоніан H₂O до форми з операторами Паулі (<code>Z</code>, <code>X</code>, <code>Y</code>), використовуючи коефіцієнти, отримані з квантово-хімічних розрахунків (наприклад, через Jordan-Wigner трансформацію). Реальні коефіцієнти залежать від геометрії молекули.</li>
        <li><strong>Анзац:</strong> Використовуємо простий анзац з обертаннями <code>Ry</code> та ентанглементом через <code>CNOT</code> для трьох кубітів, що відповідають орбіталям молекули H₂O.</li>
        <li><strong>Очікувана енергія:</strong> Функція <code>measure_energy</code> обчислює середнє значення гамільтоніана, вимірюючи кожен член (наприклад, <code>Z_0</code>, <code>Z_1</code>, <code>X_0X_1</code>).</li>
        <li><strong>Оптимізація:</strong> Спрощуємо класичну оптимізацію до ітеративного оновлення параметрів <code>θ</code> і <code>φ</code>. У реальних системах використовують складніші методи (SPSA, COBYLA).</li>
        <li><strong>Кубіти:</strong> Використовуємо три кубіти для спрощеної моделі H₂O, що дозволяє моделювати основні орбіталі.</li>
        <li><strong>Переваги Silq:</strong> Silq автоматично очищає кубіти після вимірювань, зменшуючи глибину схеми та ризик помилок.</li>
        <li><strong>Інтерпретація:</strong> Отримана енергія (~-76.4 Ха для H₂O) відповідає енергії зв’язку молекули, що впливає на її хімічну стабільність.</li>
    </ol>
               
        <br><br>Silq менш універсальний, ніж Qiskit, але його інтуїтивність робить його улюбленцем для новачків. Silq не є настільки універсальною, як Qiskit, через її фокус на високорівневій розробці та теоретичних задачах, а не на апаратній реалізації. 
        <br><br>Вона ідеально підходить для складних ймовірнісних математичних моделей, таких як у квантовій хімії чи оптимізації, де потрібна чистота коду та автоматизація квантових ресурсів. Qiskit, навпаки, є універсальнішим завдяки підтримці апаратного забезпечення та ширшій екосистемі, але вимагає більше зусиль для низькорівневих задач. 
        <br>Якщо ваша мета — швидке прототипування складних квантових алгоритмів з акцентом на математику, Silq є чудовим вибором. Для роботи з реальними квантовими пристроями чи масштабними системами Qiskit буде кращим.</p>
            

      <p><a href="https://silq.ethz.ch/" style="font-weight: 800;  color: rgb(56, 28, 28); font-size: 24px; font-style: italic;" target="_blank">Silq Documentation</a></p>
    </section>

    <section id="section7" class="section" style="background-color: #A6B8D3; padding: 20px; margin: 20px 0; border-radius: 10px; animation: fadeInSection 1s ease-in;">
      <h2 style="color: #0a041d; font-weight: 700; font-size: 35px; text-align: left;">Cirq і Google Willow: оптимізація для апаратного забезпечення</h2>
      <p style="line-height: 1.6; font-family: 'Cardo', serif; font-size: 31px; color: #271c2b; animation: colorShiftCardo 5s infinite alternate; text-align: justify;"><span style="font-weight: bold; color: rgb(56, 28, 28);">Cirq</span> від Google – це як інженер, що створює схеми, ідеально підігнані під апаратне забезпечення, зокрема <span style="font-weight: bold; color: rgb(56, 28, 28);">Google Willow</span>.
        
        У 2025 році Cirq оптимізує квантові схеми для surface code, зменшуючи помилки на 25% (NIST). 
        <br><br>Замість універсального коду, Cirq дозволяє вказати фізичне розташування кубітів, що критично для superconducting QPU.
        <br>Cirq підтримує алгоритми, як <span class="code-trigger" data-code-id="cirq-circuit" style="font-weight: bold; color: rgb(56, 28, 28);">QAOA</span>, для задач, як оптимізація логістики. 
        
        <br><br>Cirq вимагає знання апаратних деталей, але його Python-синтаксис робить це доступним. 
        <br><br>У 2025 році Cirq використовується в 35% проєктів Google Quantum AI, зокрема для симуляції матеріалів. 
        Обмеження: Cirq менш гнучкий для гібридних систем, ніж Qiskit, але його оптимізація для Willow робить його лідером для специфічних QPU.</p>
      
      <p><a href="https://quantumai.google/cirq" style="font-weight: 800;  color: rgb(56, 28, 28); font-size: 24px; font-style: italic;" target="_blank">Cirq Language Docs</a></p>
    </section>

    <section id="section8" class="section" style="background-color: #A6B8D3; padding: 20px; margin: 20px 0; border-radius: 10px; animation: fadeInSection 1s ease-in;">
      <h2 style="color: #0a041d; font-weight: 700; font-size: 35px; text-align: left;">Тенденції 2025: квантовий код для всіх</h2>
      <p style="line-height: 1.6; font-family: 'Cardo', serif; font-size: 31px; color: #271c2b; animation: colorShiftCardo 5s infinite alternate; text-align: justify;">У 2025 році квантові мови стають мостом між мікросвітом та реальністю. 
        
       <br>За Quantum Zeitgeist, 50% розробників QML використовують Python-інтегровані фреймворки, як <span style="font-weight: bold; color: rgb(56, 28, 28);">Qiskit</span> чи <span style="font-weight: bold; color: rgb(56, 28, 28);">Cirq</span>, завдяки їхній доступності. 
       
       <img src="https://www.researchgate.net/publication/358552293/figure/fig1/AS:1123220904255488@1644808140507/A-Simplified-View-of-Quantum-Computing-Systems-a-Quantum-Hardware-b-Quantum.png" style="width: 840px; height: 700px;">

        <br>Уявіть: програміст без знань квантової фізики пише код для <span style="font-weight: bold; color: rgb(56, 28, 28);">VQE</span>, що моделює молекулу, використовуючи Qiskit 2.0. 
        <br><br>Перспективи: інтеграція з AI (<span style="font-weight: bold; color: rgb(56, 28, 28);">TensorFlow Quantum</span>), хмарними платформами (<span style="font-weight: bold; color: rgb(56, 28, 28);">Azure Quantum</span>) і фокус на гібридних алгоритмах. 
        Квантові мови стають простішими, але їхня складність зростає через QECC і шум.
       
         <br>Але при цьому, квантові мови ще не універсальні, але хмарні симулятори дозволяють тестувати код без QPU. Наприклад, DHL використовує Q# для оптимізації маршрутів, досягаючи 20% економії часу.</p>
      
    </section>

    <section id="section9" class="section" style="background-color: #A6B8D3; padding: 20px; margin: 20px 0; border-radius: 10px; animation: fadeInSection 1s ease-in;">
      <h2 style="color: #0a041d; font-weight: 700;  font-size: 35px; text-align: left;">Майбутнє квантових мов:</h2>
      <p style="line-height: 1.6; font-family: 'Cardo', serif; font-size: 31px; color: #271c2b; animation: colorShiftCardo 5s infinite alternate; text-align: justify;">Майбутнє квантових мов – це як створення універсального перекладача для спілкування з мікросвітом. 
        <br>До 2035 року, за прогнозами Moody’s, 30% розробників AI використовуватимуть квантові мови для гібридних задач, як моделювання білків чи оптимізація фінансів. 
        <br><br>Уявіть: <span style="font-weight: bold; color: rgb(56, 28, 28);">Qiskit 3.0</span> інтегрується з PyTorch, дозволяючи створювати квантові нейронні мережі з кількох рядків.
        <br><span style="font-weight: bold; color: rgb(56, 28, 28);">Silq</span> може стати стандартом для інтуїтивного програмування, <br>а <span style="font-weight: bold; color: rgb(56, 28, 28);">Q#</span> – для хмарних QPU. 
        
        <br><br>В майбутньому квантові мови стануть настільки простими, що їх вивчатимуть у школах, але вони керуватимуть системами з мільйонами кубітів.
        <br> Розробники вже можуть почати з Qiskit чи Cirq, створюючи алгоритми для реальних задач. Почніть свою квантову подорож сьогодні, і, можливо, ви напишете код для наступного прориву!</p>   
      
    </section>
  </div>

  <!-- Draggable Context Button -->
  <button id="context-btn">☰</button>
  <!-- Book Button for Modal Menu -->
  <button id="book-btn">📘</button>
</div>
 
{% endblock %}

{% block js %}
     <script src="{{ url_for('static', filename='scripts/quantum_languages.js') }}"></script>
 {% endblock %}

