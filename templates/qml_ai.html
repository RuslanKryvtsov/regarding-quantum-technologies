{% extends "base.html" %}

{% block title %}Квантовий Машинне Навчання та Інтеграція з AI{% endblock %}

{% block content %}
<div class="quantum-page-container">
  <!-- Бічна панель для навігації -->
  <div class="nav-sidebar" id="sidebar-menu">
    <h3 style="color: #80090f; font-style: italic; font-size: 25px; font-weight: 900;">Навігація по веб-сторінці QML & AI</h3>
    <ul>
      <li style="color: #b8860b; font-size: 1.1em; font-size: 31px; text-align: justify; font-style: italic; font-weight: 600;"><a href="#section1" class="nav-link">Проблематика QML</a></li>
      <li style="color: #b8860b; font-size: 1.1em; font-size: 25px; text-align: justify; font-style: italic; font-weight: 600;"><a href="#section2" class="nav-link">Теоретичні основи</a></li>
      <li style="color: #b8860b; font-size: 1.1em; font-size: 25px; text-align: justify; font-style: italic; font-weight: 600;"><a href="#section3" class="nav-link">Гібридні системи</a></li>
      <li style="color: #211255; font-weight: 700;"><a href="#section4" class="nav-link">Популярні фреймворки</a></li>
      <li style="color: #211255; font-weight: 700;"><a href="#section5" class="nav-link">QSVM у дії</a></li>
      <li style="color: #0a041d; font-weight: 700;"><a href="#section6" class="nav-link">QGANs та генерація даних</a></li>
      <li style="color: #0a041d; font-weight: 700;"><a href="#section7" class="nav-link">Тренди 2025</a></li>
      <li style="color: #0a041d; font-weight: 700;"><a href="#section8" class="nav-link">Застосування в NLP</a></li>
      <li style="color: #0a041d; font-weight: 700;"><a href="#section9" class="nav-link">Майбутнє QML</a></li>
    </ul>
  </div>

  <!-- Модальне меню для book-btn -->
  <div id="modal-menu" class="context-modal">
    <div class="modal-content">
      <span id="close-modal">&times;</span>
      <h3>Контекстне меню</h3>
      <ul>
        <li><a href="#section1" class="nav-link">Проблематика QML</a></li>
        <li><a href="#section2" class="nav-link">Теоретичні основи</a></li>
        <li><a href="#section3" class="nav-link">Гібридні системи</a></li>
        <li><a href="#section4" class="nav-link">Популярні фреймворки</a></li>
        <li><a href="#section5" class="nav-link">QSVM у дії</a></li>
        <li><a href="#section6" class="nav-link">QGANs та генерація даних</a></li>
        <li><a href="#section7" class="nav-link">Тренди 2025</a></li>
        <li><a href="#section8" class="nav-link">Застосування в NLP</a></li>
        <li><a href="#section9" class="nav-link">Майбутнє QML</a></li>
      </ul>
    </div>
  </div>

  <!-- Основний вміст -->
  <div class="content">
    <div class="welcome-text">
      <h1 style="color: #7c0e14; font-size: 1.2em; font-size: 44px; text-align: center; font-style: italic; margin-right: 170px; font-weight: 900;">Поєднання штучного інтелекту з <br>квантовим світом</h1>
      <p style="font-weight: 950;  color: rgb(48, 21, 21); font-size: 29px; text-align: justify; width: 940px; margin-right: 150px;">Уявіть Всесвіт як гігантську нейронну мережу, де кубіти – це нейрони, 
        що обчислюють у всіх можливих станах одночасно. <br><br>Квантове машинне навчання (QML) – це міст між класичним AI та квантовим хаосом, що відкриває двері до нових горизонтів.</p>
    </div>

    <!-- Розділи -->
    <section id="section1" class="section" style="background-color: #A6B8D3; padding: 20px; margin: 20px 0; border-radius: 10px; animation: fadeInSection 1s ease-in;">
      <h2 style="color: #0a041d; font-weight: 700; font-size: 35px;">Проблематика QML: чому класичний AI потребує квантового поштовху</h2>
      <p style="line-height: 1.6; font-family: 'Cardo', serif; font-size: 31px; color: #271c2b; animation: colorShiftCardo 5s infinite alternate; text-align: justify;">Класичне машинне навчання (ML) – це як гігантський годинник, що цокає послідовно, обробляючи дані крок за кроком.
         <br><br>Але <span style="font-weight: bold;  color: rgb(56, 28, 28);">сучасні датасети – це не просто потік інформації, а цілі галактики даних: мільярди параметрів у NLP-моделях, складні молекулярні структури в drug discovery, багатовимірні оптимізаційні задачі в логістиці.</span> 
         <br><br>Класичні алгоритми, як TensorFlow чи PyTorch, стикаються з "прокляттям розмірності": експоненціальне зростання обчислень робить обробку таких даних повільною, а іноді й неможливою. 
        <br> <span style="font-weight: bold;  color: rgb(56, 28, 28);">Наприклад, симуляція однієї молекули для нових ліків може займати роки на класичних суперкомп’ютерах</span> через необхідність перебирати всі конфігурації атомів. 
         <br><br>У 2025 році, за даними Quantum Insider, <span style="font-weight: bold;  color: rgb(56, 28, 28);">40% компаній у сфері AI досліджують QML як рішення, що використовує квантову суперпозицію для паралельної обробки даних, наприклад, у прогнозуванні фінансових ринків чи моделюванні білків.</span> 
         <br><br> Однак виклик – декогеренція та обмежена кількість кубітів (100–1000 у 2025, MIT Quantum Index) – вимагає гібридних підходів, де класичні та квантові системи працюють разом.</p>
      <img src="https://quantumzeitgeist.com/wp-content/uploads/QUANTUM_CLASSICAL.webp" style="width: 690px; height: 500px;" alt="Квантова та класична обчислювальна технологія">
      <details>
        <summary>Прокляття розмірності</summary>
        <p>У класичному ML розмірність даних (n) веде до O(2ⁿ) обчислень для вичерпного пошуку. QML використовує квантові ядра, що дозволяють оцінити багатовимірні простори в O(log n), зменшуючи час обробки експоненціально. Джерело: <a href="https://pennylane.ai/qml/demos/" target="_blank">PennyLane QML Demos</a>.</p>
      </details>
    </section>

    <section id="section2" class="section" style="background-color: #A6B8D3; padding: 20px; margin: 20px 0; border-radius: 10px; animation: fadeInSection 1s ease-in;">
      <h2 style="color: #0a041d; font-weight: 700; font-size: 35px;">Теоретичні основи: як квантовий світ підсилює AI</h2>
      <p style="line-height: 1.6; font-family: 'Cardo', serif; font-size: 31px; color: #271c2b; animation: colorShiftCardo 5s infinite alternate; text-align: justify;">Квантове машинне навчання (QML) – це не просто "квантовий тюнінг" класичного AI, а нова парадигма, що використовує принципи суперпозиції, заплутаність та інтерференцію. 
        Уявіть нейронну мережу, де кожен нейрон може бути в тисячах станів одночасно: це кубіт у суперпозиції, що дозволяє обробляти всі можливі комбінації даних паралельно. 
        <br><br>Основний <span style="font-weight: bold;  color: rgb(56, 28, 28);">інструмент QML – квантові схеми (quantum circuits), які замінюють класичні шари нейронних мереж.</span> Наприклад, <span class="code-trigger" data-code-id="quantum-circuit">параметризовані квантові схеми</span> (PQC) – це аналог ваг у нейронній мережі, але вони кодують дані в квантових станах, дозволяючи створювати складні нелінійні відображення, недоступні класичним моделям. 
       <br> <p style="line-height: 1.6; font-family: 'Cardo', serif; font-size: 24px; color: #271c2b; animation: colorShiftCardo 5s infinite alternate; text-align: justify; font-weight: 800; font-style: italic;"> Qiskit надає інструменти у своїй бібліотеці машинного навчання Qiskit для побудови та роботи з квантовими нейронними мережами (QNN). Ось приклади коду, що ілюструють ключові компоненти та базову реалізацію 
          QNN:
        <br> <span style="line-height: 1.6; font-family: 'Cardo', serif; font-size: 25px; color: #0a010e; animation: colorShiftCardo 5s infinite alternate; text-align: justify; font-weight: 800; font-style: italic;">1. Basic Parameterized Quantum Circuit (PQC) as a building block:
        <pre style="font-size: 23px; font-weight: 800; color:#003366;"><code>
          theta = ParameterVector('θ', length=2)
          qc = QuantumCircuit(2)
          qc.ry(theta[0], 0)  # Rotation-Y gate on qubit 0 with parameter theta[0]
          qc.cry(theta[1], 0, 1) # Controlled Rotation-Y gate on qubit 1 controlled by qubit 0
          print(qc.draw())
          </code></pre>
        </span>
        <br> <span style="line-height: 1.6; font-family: 'Cardo', serif; font-size: 25px; color: #0a010e; animation: colorShiftCardo 5s infinite alternate; text-align: justify; font-weight: 800; font-style: italic;">2. Defining a Quantum Neural Network (QNN) using Qiskit Machine Learning:
          This example demonstrates creating a SamplerQNN, which is based on the measurement outcomes (samples) of a quantum circuit: </span>
        <pre style="font-size: 23px; font-weight: 800; color:#003366;"><code>
          import numpy as np
          from qiskit.circuit.library import ZZFeatureMap, RealAmplitudes
          from qiskit_machine_learning.neural_networks import SamplerQNN
          from qiskit.primitives import Sampler
          
          # Define a feature map to encode classical data into quantum states
          feature_map = ZZFeatureMap(feature_dimension=2, reps=1)
          
          # Define a variational ansatz (parameterized quantum circuit)
          ansatz = RealAmplitudes(num_qubits=2, reps=1)
          
          # Combine feature map and ansatz
          qc_qnn = feature_map.compose(ansatz)
          
          # Create a SamplerQNN
          sampler = Sampler() # Use the default Sampler primitive
          qnn = SamplerQNN(circuit=qc_qnn, sampler=sampler, input_params=feature_map.parameters, weight_params=ansatz.parameters)
          
          # Example usage:
          input_data = np.array([0.5, 0.2])
          weights = np.random.rand(ansatz.num_parameters)
          output = qnn.forward(input_data, weights)
          print(f"QNN output for input {input_data} and weights {weights}: {output}")
        </code></pre>
        <br> <span style="line-height: 1.6; font-family: 'Cardo', serif; font-size: 25px; color: #0a010e; animation: colorShiftCardo 5s infinite alternate; text-align: justify; font-weight: 800; font-style: italic;">3. Training a QNN for a simple classification task:
        This example outlines the structure for training a QNN within a classification context, often involving classical optimization:</span>
        <pre style="font-size: 23px; font-weight: 800; color:#003366;"><code>
          import numpy as np
          from qiskit.circuit.library import ZZFeatureMap, RealAmplitudes
          from qiskit_machine_learning.neural_networks import SamplerQNN
          from qiskit.primitives import Sampler
          from qiskit.algorithms.optimizers import COBYLA
          
          # ... (feature_map, ansatz, qc_qnn, sampler, qnn as defined above) ...
          
          # Define a simple dataset
          X_train = np.array([[0.1, 0.9], [0.8, 0.2]])
          y_train = np.array([0, 1]) # Binary labels
          
          # Define a loss function
          def loss_function(weights):
              predictions = []
              for x_in in X_train:
                  # Assuming QNN output is a probability for class 1
                  # and we use 1-output for class 0
                  output_prob = qnn.forward(x_in, weights)[0]
                  predictions.append(output_prob)
          
              # Simple mean squared error loss
              loss = np.mean([(y_true - pred)**2 for y_true, pred in zip(y_train, predictions)])
              return loss
          
          # Initialize weights randomly
          initial_weights = np.random.rand(ansatz.num_parameters)
          
          # Use a classical optimizer
          optimizer = COBYLA(maxiter=100)
          
          # Train the QNN
          optimal_weights, min_loss, _ = optimizer.minimize(fun=loss_function, x0=initial_weights)
          
          print(f"Optimal weights: {optimal_weights}")
          print(f"Minimum loss: {min_loss}")
        </code></pre>
        </p>
        <p style="line-height: 1.6; font-family: 'Cardo', serif; font-size: 25px; color: #0a010e; animation: colorShiftCardo 5s infinite alternate; text-align: left; font-weight: 800; font-style: italic; text-align: justify;"> Звичайно, це дуже спрощений зразок коду створення QNN (квантової нейромережі), з використанням квантових схем (quantum circuits); <br>в другому фрагменті кода
          ми вже визначаємо квантову нейромережу (QNN) використовуючи бібліотеку мови Python - numpy та фреймворк qiskit, а саме:  qiskit.circuit.library, qiskit_machine_learning.neural_networks, qiskit primitives
          <br>В третьому прикладі - тренування квантової мережі (QNN) для вирішення задачі простої класифікації.</p>
        <p style="line-height: 1.6; font-family: 'Cardo', serif; font-size: 31px; color: #271c2b; animation: colorShiftCardo 5s infinite alternate; text-align: justify;">  
       <br><span style="font-weight: bold;  color: rgb(56, 28, 28); ">Заплутаність дозволяє моделям "бачити" кореляції між даними,</span> які ігноруються класичними алгоритмами, подібно до того, як дві частинки, розділені галактиками, синхронно реагують. 
        <br><span style="font-weight: bold;  color: rgb(56, 28, 28);">Інтерференція підсилює правильні рішення,</span> пригнічуючи помилкові, як хвилі, що створюють гармонію в океані хаосу. 
        <br><br><span style="font-weight: bold;  color: rgb(56, 28, 28);">У 2025 році QML використовує гібридні системи: класичні алгоритми (наприклад, TensorFlow) оптимізують параметри квантових схем,</span> а квантові ядра (quantum kernels) оцінюють відстані в багатовимірних просторах. 
        <br><br>Це дозволяє, наприклад, класифікувати молекулярні структури для drug discovery у 10 разів швидше, ніж класичні SVM. <span style="font-weight: bold;  color: rgb(56, 28, 28);">Однак обмеження – декогеренція та потреба в error correction (QECC) – роблять гібридний підхід критичним.</span></p>
      <div id="quantum-circuit-code" class="code-block" style="display: none;">
        <pre style="font-size: 23px; font-weight: 800; color:#003366;">
import pennylane as qml
dev = qml.device('default.qubit', wires=2)
@qml.qnode(dev)
def circuit(params):
    qml.RX(params[0], wires=0)
    qml.RY(params[1], wires=1)
    qml.CNOT(wires=[0, 1])
    return qml.expval(qml.PauliZ(0))
        </pre>
      </div>
    </section>

    <section id="section3" class="section" style="background-color: #A6B8D3; padding: 20px; margin: 20px 0; border-radius: 10px; animation: fadeInSection 1s ease-in;">
      <h2 style="color: #0a041d; font-weight: 700; font-size: 35px;">Гібридні системи: cинергія класичного та квантового AI</h2>
      <p style="line-height: 1.6; font-family: 'Cardo', serif; font-size: 31px; color: #271c2b; animation: colorShiftCardo 5s infinite alternate; text-align: justify;">Гібридні QML системи – це як оркестр, де класичні інструменти (CPU/GPU) грають у парі з квантовими (QPU). 
        У 2025 році, коли кількість кубітів обмежена (100–1000, MIT), гібридний підхід є основою QML. 
        <br><br>Класичні алгоритми, такі як TensorFlow чи PyTorch, використовуються для оптимізації параметрів квантових схем, тоді як QPU виконують обчислення, що потребують суперпозиції чи заплутаністі.
        <br><br> Наприклад, у <span class="code-trigger" data-code-id="hybrid-qsvm">QSVM</span> (Quantum Support Vector Machine) квантовий комп’ютер обчислює ядро (kernel), яке оцінює відстані між точками даних у багатовимірному просторі, 
         а класичний оптимізатор (наприклад, SGD) налаштовує модель. 
         <br><br> Це дозволяє обробляти датасети з експоненціальною розмірністю, наприклад, для прогнозування фінансових ринків чи аналізу геномних даних. 
         <br><br> Парадокс: <span style="font-weight: bold;  color: rgb(56, 28, 28);">квантовий комп’ютер – це "геній хаосу", але потребує класичного "диригента" для стабільності.</span> 
         <br><br> У 2025 році NVIDIA та Quantinuum <span style="font-weight: bold;  color: rgb(56, 28, 28); text-decoration: underline;">досягли 50-кратного прискорення в ML-задачах, таких як класифікація зображень, завдяки гібридним системам.</span>
         <br> Обмеження – висока чутливість до декогеренції та потреба в QECC, що збільшує overhead (49 фізичних кубітів на 1 логічний у surface code).
         <br><br> Проте гібридний підхід дозволяє використовувати сучасні квантові процесори (<span style="font-weight: bold;  color: rgb(56, 28, 28);">Google Willow, IBM Loon)</span> для практичних задач, як-от оптимізація логістики чи моделювання хімічних реакцій.</p>
      <div id="hybrid-qsvm-code" class="code-block" style="display: none;">
        <pre style="font-size: 23px; font-weight: 800; color:#003366;">
import pennylane as qml
from pennylane import numpy as np
dev = qml.device('default.qubit', wires=4)
@qml.qnode(dev)
def kernel_circuit(x1, x2, params):
    qml.AngleEmbedding(x1, wires=range(4))
    qml.adjoint(qml.AngleEmbedding)(x2, wires=range(4))
    return qml.probs(wires=range(4))
        </pre>
      </div>
    </section>

    <section id="section4" class="section" style="background-color: #A6B8D3; padding: 20px; margin: 20px 0; border-radius: 10px; animation: fadeInSection 1s ease-in;">
      <h2 style="color: #0a041d; font-weight: 700; font-size: 35px;">Популярні фреймворки: інструменти для QML</h2>
      <p style="line-height: 1.6; font-family: 'Cardo', serif; font-size: 31px; color: #271c2b; animation: colorShiftCardo 5s infinite alternate; text-align: justify;">У 2025 році <span style="font-weight: bold;  color: rgb(61, 9, 9);"> QML – це екосистема фреймворків, що поєднують квантові та класичні</span> обчислення. 
        Уявіть їх як космічні кораблі, що дозволяють подорожувати між мікросвітом кубітів і макросвітом даних.
       <p style="color: #eed8d8; font-size: 1.1em; font-size: 25px; text-align: justify; font-weight: 600; font-style: italic;">
       <ol style="line-height: 1.6; font-family: 'Cardo', serif; font-size: 31px; color: #271c2b; animation: colorShiftCardo 5s infinite alternate; text-align: justify;">
        <span style="font-weight: bold;  color: rgb(61, 9, 9);"> Основні гравці:</span>
         <li> <span style="font-weight: bold;  color: rgb(61, 9, 9);"> PennyLane (гібридні схеми, інтеграція з PyTorch/TensorFlow)</span> – лідер завдяки простоті: він дозволяє створювати параметризовані квантові схеми, які інтегруються з класичними ML-фреймворками, подібно до того, 
          як GPS направляє корабель через бурхливі хвилі; </li>
         <li><span style="font-weight: bold;  color: rgb(61, 9, 9);"> Qiskit (IBM, для superconducting кубітів)</span> - пропонує інструменти для роботи з реальними квантовими процесорами IBM, включаючи error mitigation;</li> 
         <li><span style="font-weight: bold;  color: rgb(61, 9, 9);">Cirq (Google, оптимізований для Willow)</span> - фокусується на оптимізації схем для Google Willow, з підтримкою surface code;</li> 
         <li><span style="font-weight: bold;  color: rgb(61, 9, 9);">TensorFlow Quantum (TFQ, для масштабних ML-задач)</span> - – це міст до великих нейронних мереж, де квантові ядра додають "суперпозицію" до класичних моделей. Наприклад, у задачі класифікації 
          геномних даних PennyLane може зменшити час навчання з годин до хвилин завдяки квантовим ядрам.</li> 
       </ol>  
       <p style="line-height: 1.6; font-family: 'Cardo', serif; font-size: 31px; color: #271c2b; animation: colorShiftCardo 5s infinite alternate; text-align: justify;">Парадокс: ці фреймворки – класичні за інтерфейсом, але квантові за суттю, що робить їх доступними для програмістів без PhD з фізики.</p>
       <p style="line-height: 1.6; font-family: 'Cardo', serif; font-size: 31px; color: #271c2b; animation: colorShiftCardo 5s infinite alternate; text-align: justify;">У 2025 році 60% QML-досліджень використовують PennyLane через його гнучкість (Moody’s).</p>
      <div id="pennylane-code" class="code-block" style="display: none;">
        <pre style="font-size: 23px; font-weight: 800; color:#003366;">
import pennylane as qml
from pennylane import numpy as np
dev = qml.device('default.qubit', wires=2)
@qml.qnode(dev)
def circuit(x, weights):
    qml.AngleEmbedding(x, wires=range(2))
    for i in range(2):
        qml.RX(weights[i, 0], wires=i)
        qml.RY(weights[i, 1], wires=i)
    qml.CNOT(wires=[0, 1])
    return qml.expval(qml.PauliZ(0))
weights = np.random.random((2, 2))
        </pre>
      </div>
      <table style="width: 100%; border-collapse: collapse; margin: 20px 0; color: #ffffff;">
        <thead>
          <tr style="background: #003366;">
            <th style="padding: 10px; border: 1px solid #4a90e2;">Фреймворк</th>
            <th style="padding: 10px; border: 1px solid #4a90e2;">Розробник</th>
            <th style="padding: 10px; border: 1px solid #4a90e2;">Особливості</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td style="padding: 10px; border: 1px solid #4a90e2;">PennyLane</td>
            <td style="padding: 10px; border: 1px solid #4a90e2;">Xanadu</td>
            <td style="padding: 10px; border: 1px solid #4a90e2;">Гібридні схеми, PyTorch/TensorFlow</td>
          </tr>
          <tr>
            <td style="padding: 10px; border: 1px solid #4a90e2;">Qiskit</td>
            <td style="padding: 10px; border: 1px solid #4a90e2;">IBM</td>
            <td style="padding: 10px; border: 1px solid #4a90e2;">Error mitigation, superconducting</td>
          </tr>
          <tr>
            <td style="padding: 10px; border: 1px solid #4a90e2;">Cirq</td>
            <td style="padding: 10px; border: 1px solid #4a90e2;">Google</td>
            <td style="padding: 10px; border: 1px solid #4a90e2;">Оптимізація для Willow</td>
          </tr>
        </tbody>
      </table>
    </section>

    <section id="section5" class="section" style="background-color: #A6B8D3; padding: 20px; margin: 20px 0; border-radius: 10px; animation: fadeInSection 1s ease-in;">
      <h2 style="color: #0a041d; font-weight: 700; font-size: 35px;">QSVM у дії: Класифікація з квантовими ядрами</h2>
      <p style="line-height: 1.6; font-family: 'Cardo', serif; font-size: 31px; color: #271c2b; animation: colorShiftCardo 5s infinite alternate; text-align: justify;">Quantum Support Vector Machine (QSVM) – це як телескоп, що дозволяє бачити зірки в багатовимірному просторі даних. 
        У класичному SVM ядро (kernel) обчислює відстані між точками даних, але в багатовимірних датасетах (наприклад, геномні послідовності) це займає O(n²) часу. 
        <br><br>QSVM використовує квантові ядра, які кодують дані в суперпозицію, дозволяючи оцінити відстані в O(log n). 
        <br><br>Уявіть: замість того, щоб обчислювати кожну пару точок, квантовий комп’ютер "відчуває" весь простір одразу, як океанська течія, що несе інформацію про всі глибини. 
        <br><br> У 2025 році QSVM застосовується в drug discovery для класифікації молекул за їхньою активністю, досягаючи точності 95% проти 80% для класичного SVM (NVIDIA GTC).
         Наприклад, Quantinuum H2 використовує QSVM для аналізу геномних даних, зменшуючи час обробки з 10 годин до 12 хвилин. 
         <br><br>Код QSVM у PennyLane дозволяє легко експериментувати: дані кодуються в квантові стани через AngleEmbedding, а ядро обчислюється через вимірювання ймовірностей. 
         <br><br>Обмеження – чутливість до шуму, що вимагає QECC, і потреба в гібридних системах для оптимізації.</p>
      <div id="qsvm-code" class="code-block" style="display: none;">
        <pre style="font-size: 23px; font-weight: 800; color:#003366;">
import pennylane as qml
from pennylane import numpy as np
dev = qml.device('default.qubit', wires=4)
@qml.qnode(dev)
def quantum_kernel(x1, x2):
    qml.AngleEmbedding(x1, wires=range(4))
    qml.adjoint(qml.AngleEmbedding)(x2, wires=range(4))
    return qml.probs(wires=range(4))
from sklearn.svm import SVC
svm = SVC(kernel=lambda x1, x2: quantum_kernel(x1, x2)[0])
        </pre>
      </div>
    </section>

    <section id="section6" class="section" style="background-color: #A6B8D3; padding: 20px; margin: 20px 0; border-radius: 10px; animation: fadeInSection 1s ease-in;">
      <h2 style="color: #0a041d; font-weight: 700; font-size: 35px;">QGANs: Генерація даних у квантовому стилі</h2>
      <p style="line-height: 1.6; font-family: 'Cardo', serif; font-size: 31px; color: #271c2b; animation: colorShiftCardo 5s infinite alternate; text-align: justify;">Quantum Generative Adversarial Networks (QGANs) – це як художник, що малює картини в усіх можливих стилях одночасно.
         У класичних GANs генератор і дискримінатор змагаються, щоб створювати реалістичні дані, але для великих датасетів (наприклад, зображень чи молекул) це потребує величезних ресурсів.
         <br><br> QGANs використовують квантові схеми для генерації даних у суперпозиції, дозволяючи моделювати складні розподіли з меншою кількістю параметрів. 
         <br><br>Уявіть: замість того, щоб малювати кожен піксель окремо, QGAN "уявляє" всю картину одразу, використовуючи заплутаність для створення корельованих структур.
         <br><br> У 2025 році QGANs застосовуються в drug discovery для генерації нових молекулярних структур, досягаючи 30% вищої точності порівняно з класичними GANs (Quantum Insider). Наприклад, PennyLane дозволяє створювати <span class="code-trigger" data-code-id="qgan">QGAN</span>, де генератор – це квантова схема, а дискримінатор – класична нейронна мережа. Обмеження: декогеренція може спотворити згенеровані дані, а навчання QGANs вимагає гібридних систем із QECC. Проте потенціал величезний: від генерації синтетичних даних для AI до моделювання фінансових ринків.</p>
      <div id="qgan-code" class="code-block" style="display: none;">
        <pre style="font-size: 23px; font-weight: 800; color:#003366;">
import pennylane as qml
from pennylane import numpy as np
dev = qml.device('default.qubit', wires=3)
@qml.qnode(dev)
def generator_circuit(params):
    for i in range(3):
        qml.RX(params[i], wires=i)
        qml.RY(params[i + 3], wires=i)
    qml.CNOT(wires=[0, 1])
    qml.CNOT(wires=[1, 2])
    return qml.probs(wires=range(3))
        </pre>
      </div>
    </section>

    <section id="section7" class="section" style="background-color: #A6B8D3; padding: 20px; margin: 20px 0; border-radius: 10px; animation: fadeInSection 1s ease-in;">
      <h2 style="color: #0a041d; font-weight: 700; font-size: 35px;">Тренди 2025: QML на межі реальності</h2>
      <p style="line-height: 1.6; font-family: 'Cardo', serif; font-size: 31px; color: #271c2b; animation: colorShiftCardo 5s infinite alternate; text-align: justify;">У 2025 році QML переживає бум: інвестиції в сектор зросли на 40% (Moody’s), а фокус змістився на data-scarce задачі, де традиційний ML слабкий.
          <br><br>NVIDIA та Quantinuum досягли 50-кратного прискорення в задачах класифікації та генерації даних, наприклад, у моделюванні білків для healthcare. 
          <br><br>Google Willow інтегрує QML із surface code, забезпечуючи стійкість до шуму, тоді як IBM Loon фокусується на гібридних системах для фінансових прогнозів. 
          <br><br> QML ще не замінив класичний AI, але вже революціонізує нішеві задачі, як-от оптимізація логістики (DHL, 2025) чи аналіз медичних зображень.
         <br><br>Обмеження – висока вартість доступу до квантових процесорів і потреба в QECC – компенсуються хмарними платформами, як IBM Quantum Experience, що роблять QML доступним для розробників.</p>
    </section>

    <section id="section8" class="section" style="background-color: #A6B8D3; padding: 20px; margin: 20px 0; border-radius: 10px; animation: fadeInSection 1s ease-in;">
      <h2 style="color: #0a041d; font-weight: 700; font-size: 35px;">Застосування в NLP: квантовий підхід до обробки природної мови</h2>
      <p style="line-height: 1.6; font-family: 'Cardo', serif; font-size: 31px; color: #271c2b; animation: colorShiftCardo 5s infinite alternate; text-align: justify;">Обробка природної мови (NLP) – це як розшифровка космічних сигналів: тексти, як зоряне небо, ховають складні патерни.
         Класичні моделі, як BERT чи GPT, потребують мільярдів параметрів, щоб "зрозуміти" мову, але QML використовує квантові ядра для аналізу семантичних зв’язків у багатовимірних просторах. 
         <br><br> У 2025 році QML застосовується в NLP для задач, як-от sentiment analysis чи переклад, досягаючи 20% вищої точності в data-scarce сценаріях (Quantum Insider). 
         <br><br> Наприклад, QSVM із квантовим ядром може класифікувати твіти за емоційним забарвленням швидше, ніж класичний SVM, завдяки паралельній обробці.
         <br><br> PennyLane та Cirq дозволяють створювати квантові моделі NLP, інтегровані з TensorFlow. 
         <br><br> У майбутньому QML може революціонізувати чат-боти, роблячи їх "інтуїтивно" розумними.</p>
    </section>

    <section id="section9" class="section" style="background-color: #A6B8D3; padding: 20px; margin: 20px 0; border-radius: 10px; animation: fadeInSection 1s ease-in;">
      <h2 style="color: #0a041d; font-weight: 700; font-size: 35px;">Майбутнє QML: Куди веде мікросвіт</h2>
      <p style="line-height: 1.6; font-family: 'Cardo', serif; font-size: 31px; color: #271c2b; animation: colorShiftCardo 5s infinite alternate; text-align: justify;">Майбутнє QML – це як космічна подорож до нових галактик: у 2025 році ми лише на старті, але потенціал величезний. 
        <br><p style="line-height: 1.6; font-family: 'Cardo', serif; font-size: 31px; color: #271c2b; animation: colorShiftCardo 5s infinite alternate; text-align: justify;">За прогнозами Moody’s, до 2035 року QML може зайняти 20% ринку AI, особливо в healthcare (моделювання білків), фінансах (оптимізація портфелів) та логістиці (маршрутизація).</p> 
        <br><p style="line-height: 1.6; font-family: 'Cardo', serif; font-size: 31px; color: #271c2b; animation: colorShiftCardo 5s infinite alternate; text-align: justify;">Уявіть квантову нейронну мережу, яка не просто вчиться, а "відчуває" дані, використовуючи суперпозицію для експоненціального прискорення. </p>
        <br><p style="line-height: 1.6; font-family: 'Cardo', serif; font-size: 31px; color: #271c2b; animation: colorShiftCardo 5s infinite alternate; text-align: justify;">Хоча сучасні квантові комп’ютери обмежені 1000 кубітів, гібридні системи дозволяють досягати quantum advantage уже сьогодні. </p>
        <p style="line-height: 1.6; font-family: 'Cardo', serif; font-size: 31px; color: #271c2b; animation: colorShiftCardo 5s infinite alternate; text-align: justify;">Наприклад, IBM планує до 2030 року запустити fault-tolerant QML-системи з мільйонами логічних кубітів, що зробить QML основою для AI в реальному часі.</p> 
        <br><p style="line-height: 1.6; font-family: 'Cardo', serif; font-size: 31px; color: #271c2b; animation: colorShiftCardo 5s infinite alternate; text-align: justify;"> Розробники можуть почати з <span style="color:#271c2b ;">PennyLane чи Qiskit</span>, експериментуючи з простими моделями, як QSVM чи QGANs. </p>
        <br><p style="line-height: 1.6; font-family: 'Cardo', serif; font-size: 31px; color: #271c2b; animation: colorShiftCardo 5s infinite alternate; text-align: justify;">Виклик – інтеграція з класичними системами та подолання декогеренції – буде вирішено через прогрес у QECC та хмарних платформах. Почніть свою подорож у QML уже сьогодні, і, 
          можливо, ви створите наступний прорив у AI!</p>
    </section>
  </div>

  <!-- Пересувна кнопка контекстного меню -->
  <button id="context-btn">☰</button>
  <!-- Пересувна кнопка Book -->
  <button id="book-btn">📘</button>
</div>

<!-- Вбудовані стилі CSS -->
<style>
  .quantum-page-container {
    position: relative;
    min-height: 100vh;
    background: radial-gradient(circle, #e2e5e7 0%, #e2e5e7 100%);
    padding: 20px;
    overflow-x: hidden;
    font-family: 'Arial', sans-serif;
    width: 100%; max-width: 1400px; margin: 0 auto;
    margin-left: 280px;
    
  }

  .nav-sidebar {
    position: fixed;
    top: 0;
    left: 0;
    width: 310px;
    height: 100vh;
    padding: 20px;
    z-index: 999;
    overflow-y: auto;
    background-color: #b3c6ca;
    transition: transform 0.3s ease;
  }

  .nav-sidebar.hidden {
    transform: translateX(-310px);
  }

  .nav-sidebar h3 {
    color: #2c2104;
    text-align: center;
    margin-bottom: 31px;
    font-size: 31px;
  }

  .nav-sidebar ul {
    list-style: none;
    padding: 0;
  }

  .nav-link {
    display: block;
    padding: 14px;
    margin: 10px 0;
    background: linear-gradient(45deg, #7eade4, #b3c6ca);
    color: #211255;
    text-align: left;
    font-style: italic;
    font-weight: 800;
    text-decoration: none;
    border-radius: 10px;
    transition: transform 0.3s, box-shadow 0.3s;
    font-size: 23px;
  }

  .nav-link:hover {
    transform: scale(1.06);
    box-shadow: 0 0 12px rgba(0, 255, 255, 0.9);
  }

  .content {
   
    margin-left: 280px;
    margin-right: 10px;
    padding: 30px;
    position: relative;
    z-index: 2;
    width: 1450px;
  }

  .welcome-text {
    text-align: center;
    color: #00d4ff;
    animation: fadeIn 2s ease-in-out;
    padding: 40px 20px;
    background-image: url('https://www.ibusinesstalk.co.uk/wp-content/uploads/2025/04/Quantum-AI-in-Finance.jpg');
    background-size: cover;
    background-position: center;
    background-repeat: no-repeat;
    border-radius: 10px;
    margin: 20px 0;
    width: 100%;
    min-height: 170px;
    background-color: rgba(197, 210, 212, 0.3);
    background-blend-mode: overlay;
  }

  .welcome-text h1 {
    font-size: 3em;
    margin: 0;
    font-family: 'Georgia', serif;
  }

  .welcome-text p {
    font-size: 1.3em;
    margin: 15px 0;
  }

  .section {
    background-color: #A6B8D3;
    padding: 25px;
    
    border-radius: 12px;

    width: 100%; max-width: 1450px; margin: 20px auto;
    
    color: #ffffff;
    animation: fadeInSection 1.2s ease-in;
    box-shadow: 0 0 12px rgba(0, 255, 255, 0.4);
    margin-left: 10px;
  }

  .section h2 {
    color: #4a90e2;
    font-size: 2em;
    font-family: 'Georgia', serif;
  }

  .section p {
    font-size: 1.15em;
    line-height: 1.7;
  }

  .section table {
    width: 100%;
    border-collapse: collapse;
    margin: 20px 0;
  }

  .section th, .section td {
    padding: 12px;
    border: 1px solid #4a90e2;
    text-align: left;
  }

  .section th {
    background: #003366;
    color: #ffffff;
  }

  .section a {
    color: #00d4ff;
    text-decoration: none;
    transition: color 0.3s;
  }

  .section a:hover {
    color: #b8860b;
    text-decoration: underline;
  }

  .code-trigger {
    color: #00d4ff;
    cursor: pointer;
    text-decoration: underline;
  }

  .code-trigger:hover {
    color: #b8860b;
  }

  .code-block {
    background: #002244;
    padding: 15px;
    border-radius: 8px;
    margin: 10px 0;
    font-size: 0.9em;
    color: #ffffff;
    border: 1px solid #4a90e2;
  }

  .simulation-box {
    background: linear-gradient(45deg, #003366, #001233);
    padding: 25px;
    border-radius: 12px;
    margin: 25px 0;
    text-align: center;
    box-shadow: 0 0 12px rgba(0, 255, 255, 0.6);
  }

  .simulation-box h3 {
    color: #b8860b;
    margin-bottom: 15px;
    font-size: 1.5em;
  }

  #simulate-qml-btn {
    background: linear-gradient(45deg, #4a90e2, #00d4ff);
    border: none;
    padding: 12px 25px;
    color: #ffffff;
    font-weight: bold;
    border-radius: 8px;
    cursor: pointer;
    transition: transform 0.3s, box-shadow 0.3s;
  }

  #simulate-qml-btn:hover {
    transform: scale(1.06);
    box-shadow: 0 0 12px rgba(0, 255, 255, 0.9);
  }

  #qml-simulation-result {
    margin-top: 15px;
    font-size: 1.3em;
    color: #00d4ff;
    text-shadow: 0 0 6px #00d4ff;
  }

  .action-buttons {
    display: flex;
    justify-content: center;
    gap: 25px;
    margin: 25px 0;
  }

  .action-btn {
    background: linear-gradient(45deg, #4a90e2, #00d4ff);
    padding: 14px 25px;
    color: #ffffff;
    text-decoration: none;
    border-radius: 10px;
    font-weight: bold;
    font-size: 15px;
    transition: transform 0.3s, box-shadow 0.3s;
  }

  .action-btn:hover {
    transform: scale(1.06);
    box-shadow: 0 0 12px rgba(0, 255, 255, 0.9);
  }

  details {
    margin: 15px 0;
    color: #ffffff;
  }

  summary {
    color: #4a90e2;
    cursor: pointer;
    font-weight: bold;
    font-size: 1.2em;
  }

  .context-modal {
    display: none;
    position: fixed;
    z-index: 1001;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    overflow: auto;
    background-color: rgba(0, 0, 0, 0.65);
  }

  .modal-content {
    background: linear-gradient(45deg, #003366, #001233);
    margin: 15% auto;
    padding: 20px;
    border: 1px solid #4a90e2;
    width: 300px;
    border-radius: 12px;
    text-align: center;
    box-shadow: 0 0 12px rgba(0, 255, 255, 0.6);
    animation: fadeIn 0.3s ease-in;
  }

  #close-modal {
    color: #00d4ff;
    float: right;
    font-size: 28px;
    font-weight: bold;
  }

  #close-modal:hover,
  #close-modal:focus {
    color: #b8860b;
    text-decoration: none;
    cursor: pointer;
  }

  .modal-content h3 {
    color: #4a90e2;
    font-size: 25px;
    margin-bottom: 20px;
  }

  .modal-content ul {
    list-style: none;
    padding: 0;
  }

  .modal-content .nav-link {
    font-size: 20px;
    color: #00d4ff;
    background: none;
    box-shadow: none;
    font-style: normal;
  }

  .modal-content .nav-link:hover {
    background: #4a90e2;
    color: #b8860b;
    transform: scale(1.05);
  }

  @keyframes twinkle {
    0%, 100% { opacity: 0.35; }
    50% { opacity: 0.55; }
  }

  @keyframes fadeIn {
    0% { opacity: 0; }
    100% { opacity: 1; }
  }

  @keyframes fadeInSection {
    0% { opacity: 0; transform: translateY(25px); }
    100% { opacity: 1; transform: translateY(0); }
  }

  @keyframes pulseBtn {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.06); }
  }

  @keyframes colorShiftCardo {
    0% { color: #271c2b; }
    100% { color: #4a2c5b; }
  }

  #context-btn, #book-btn {
    position: fixed;
    width: 45px;
    height: 45px;
    background: linear-gradient(45deg, #4a90e2, #00d4ff);
    color: #ffffff;
    border: none;
    border-radius: 50%;
    cursor: move;
    font-size: 22px;
    z-index: 1000;
    box-shadow: 0 0 12px rgba(0, 255, 255, 0.6);
    animation: pulseBtn 2s infinite;
  }

  #context-btn {
    bottom: 25px;
    right: 25px;
  }

  #book-btn {
    bottom: 25px;
    right: 80px;
  }

  #context-btn:hover, #book-btn:hover {
    transform: scale(1.1);
  }

  @media (min-width: 1450px) {
  .quantum-page-container { width: 100%; }
  .content { width: 100%; max-width: 1450px; margin: 0 auto; }
  .section { width: 100%; max-width: 1500px; margin: 20px auto; }
}
  @media (max-width: 1400px) {
    .quantum-page-container {
      width: auto;
      margin-left: 0;
      padding: 10px;
    }
    .nav-sidebar {
      width: 250px;
    }
    .nav-sidebar h3 {
      font-size: 20px;
    }
    .nav-link {
      font-size: 18px;
      padding: 10px;
    }
    .content {
      margin-left: 0;
      padding: 20px;
      width: auto;
    }
    .welcome-text h1 {
      font-size: 2.2em;
    }
    .welcome-text p {
      font-size: 1.1em;
    }
    .section h2 {
      font-size: 1.6em;
    }
    .section p {
      font-size: 1em;
    }
    .section table {
      font-size: 0.9em;
    }
    #context-btn, #book-btn {
      width: 40px;
      height: 40px;
      font-size: 20px;
    }
    #book-btn {
      right: 70px;
    }
    .modal-content {
      width: 100%;
    }
    .modal-content .nav-link {
      font-size: 16px;
    }
  }
</style>

<!-- Вбудований JavaScript -->
<script>
  // Smooth scrolling for navigation links
  document.querySelectorAll('.nav-link').forEach(link => {
    link.addEventListener('click', function(e) {
      e.preventDefault();
      const targetId = this.getAttribute('href').substring(1);
      const target = document.getElementById(targetId);
      if (target) {
        target.scrollIntoView({ behavior: 'smooth' });
        // Highlight the section temporarily
        document.querySelectorAll('.section').forEach(sec => sec.classList.remove('highlight'));
        target.classList.add('highlight');
        setTimeout(() => target.classList.remove('highlight'), 2000);
        // Close modal if clicking from modal menu
        const modal = document.getElementById('modal-menu');
        if (modal.style.display === 'block') {
          modal.style.display = 'none';
        }
      }
    });
  });

  // Toggle code blocks
  document.querySelectorAll('.code-trigger').forEach(trigger => {
    trigger.addEventListener('click', () => {
      const codeId = trigger.getAttribute('data-code-id');
      const codeBlock = document.getElementById(`${codeId}-code`);
      codeBlock.style.display = codeBlock.style.display === 'none' ? 'block' : 'none';
    });
  });

  // Draggable context button for toggling sidebar
  const contextBtn = document.getElementById('context-btn');
  let isDragging = false;
  let currentX;
  let currentY;
  let initialX;
  let initialY;

  contextBtn.addEventListener('mousedown', function(e) {
    e.preventDefault();
    initialX = e.clientX - currentX;
    initialY = e.clientY - currentY;
    isDragging = true;
  });

  document.addEventListener('mousemove', function(e) {
    if (isDragging) {
      e.preventDefault();
      currentX = e.clientX - initialX;
      currentY = e.clientY - initialY;
      contextBtn.style.left = currentX + 'px';
      contextBtn.style.top = currentY + 'px';
    }
  });

  document.addEventListener('mouseup', function() {
    isDragging = false;
  });

  contextBtn.ondragstart = function() {
    return false;
  };

  // Initialize position
  contextBtn.style.position = 'fixed';
  currentX = window.innerWidth - 70; // Adjust for right: 25px
  currentY = window.innerHeight - 70; // Adjust for bottom: 25px
  contextBtn.style.left = currentX + 'px';
  contextBtn.style.top = currentY + 'px';

  // Toggle sidebar visibility
  contextBtn.addEventListener('click', () => {
    const sidebar = document.getElementById('sidebar-menu');
    sidebar.classList.toggle('hidden');
  });

  // Modal menu for book button
  const bookBtn = document.getElementById('book-btn');
  const modal = document.getElementById('modal-menu');
  const closeModal = document.getElementById('close-modal');

  bookBtn.addEventListener('click', () => {
    modal.style.display = 'block';
  });

  closeModal.addEventListener('click', () => {
    modal.style.display = 'none';
  });

  window.addEventListener('click', (e) => {
    if (e.target === modal) {
      modal.style.display = 'none';
    }
  });

  // Highlight style
  const style = document.createElement('style');
  style.textContent = `
    .highlight {
      background: linear-gradient(45deg, #E0E0E0, #E0E0E0) !important;
      transform: scale(1.02) !important;
      transition: background 0.3s, transform 0.3s;
    }
  `;
  document.head.appendChild(style);
</script>

{% endblock %}