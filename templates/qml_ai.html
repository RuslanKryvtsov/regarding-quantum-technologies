

<xaiArtifact artifact_id="e34bfd65-2ee3-4443-9c18-7091310cbf60" artifact_version_id="020e538d-3f63-4158-a2fc-31930708eaaf" title="qml_ai.html" contentType="text/html">
{% extends "base.html" %}

{% block title %}Квантовий Машинне Навчання та Інтеграція з AI{% endblock %}

{% block content %}
<div class="container">
  <!-- Космічний фон із анімованими зірками -->
  <div class="space-bg">
    <div class="stars top-stars"></div>
    <div class="stars left-stars"></div>
    <div class="stars right-stars"></div>
  </div>

  <!-- Бічна панель для навігації -->
  <div class="sidebar">
    <h3 style="color: #0a041d; font-weight: 700;">Навігація по QML & AI</h3>
    <ul>
      <li style="color: #b8860b; font-size: 1.1em; font-size: 31px; text-align: justify; font-style: italic; font-weight: 600;"><a href="#section1" class="nav-button">Проблематика QML</a></li>
      <li style="color: #b8860b; font-size: 1.1em; font-size: 25px; text-align: justify; font-style: italic; font-weight: 600;"><a href="#section2" class="nav-button">Теоретичні основи</a></li>
      <li style="color: #b8860b; font-size: 1.1em; font-size: 25px; text-align: justify; font-style: italic; font-weight: 600;"><a href="#section3" class="nav-button">Гібридні системи</a></li>
      <li style="color: #211255; font-weight: 700;"><a href="#section5" class="nav-button"> Популярні фреймворки</a></li>
      <li style="color: #211255; font-weight: 700;"><a href="#section5" class="nav-button">QSVM у дії</a></li>
      <li style="color: #0a041d; font-weight: 700;"><a href="#section6" class="nav-button">QGANs та генерація даних</a></li>
      <li style="color: #0a041d; font-weight: 700;"><a href="#section7" class="nav-button">Тренди 2025</a></li>
      <li style="color: #0a041d; font-weight: 700;"><a href="#section8" class="nav-button">Застосування в NLP</a></li>
      <li style="color: #0a041d; font-weight: 700;"><a href="#section9" class="nav-button">Майбутнє QML</a></li>
    </ul>
  </div>

  <!-- Основний вміст -->
  <div class="content">
    <div class="welcome-text">
      <h1 style="color: #7c0e14; font-size: 1.2em; font-size: 44px; text-align: center; font-style: italic; margin-right: 170px; font-weight: 900;">Поєднання штучного інтелекту з <br>квантовим світом</h1>
     
      <p style="font-weight: bold;  color: rgb(56, 28, 28); font-size: 29px; text-align: justify; width: 1000px; margin-right: 150px;">Уявіть Всесвіт як гігантську нейронну мережу, де кубіти – це нейрони, 
        що обчислюють у всіх можливих станах одночасно. <br><br>Квантове машинне навчання (QML) – це міст між класичним AI та квантовим хаосом, що відкриває двері до нових горизонтів.</p>
    </div>

    
    <!-- Розділи -->
    <section id="section1" class="section"  style="background-color: #A6B8D3; padding: 20px; margin: 20px 0; border-radius: 10px; animation: fadeInSection 1s ease-in;">
      <h2  style="color: #0a041d; font-weight: 700; font-size: 35px;">Проблематика QML: чому класичний AI потребує квантового поштовху</h2>
      <p style="line-height: 1.6; font-family: 'Cardo', serif; font-size: 31px; color: #271c2b; animation: colorShiftCardo 5s infinite alternate; text-align: justify;">Класичне машинне навчання (ML) – це як гігантський годинник, що цокає послідовно, обробляючи дані крок за кроком.
         <br><br>Але <span style="font-weight: bold;  color: rgb(56, 28, 28);">сучасні датасети – це не просто потік інформації, а цілі галактики даних: мільярди параметрів у NLP-моделях, складні молекулярні структури в drug discovery, багатовимірні оптимізаційні задачі в логістиці.</span> 
         <br><br>Класичні алгоритми, як TensorFlow чи PyTorch, стикаються з "прокляттям розмірності": експоненціальне зростання обчислень робить обробку таких даних повільною, а іноді й неможливою. 
        <br> <span style="font-weight: bold;  color: rgb(56, 28, 28);">Наприклад, симуляція однієї молекули для нових ліків може займати роки на класичних суперкомп’ютерах</span> через необхідність перебирати всі конфігурації атомів. 
         <br><br>У 2025 році, за даними Quantum Insider, <span style="font-weight: bold;  color: rgb(56, 28, 28);">40% компаній у сфері AI досліджують QML як рішення, що використовує квантову суперпозицію для паралельної обробки даних, наприклад, у прогнозуванні фінансових ринків чи моделюванні білків.</span> 
        
         
         <br> <br> Однак виклик – декогеренція та обмежена кількість кубітів (100–1000 у 2025, MIT Quantum Index) – вимагає гібридних підходів, де класичні та квантові системи працюють разом.</p>

         <img src="https://quantumzeitgeist.com/wp-content/uploads/QUANTUM_CLASSICAL.webp" style="width: 690px; height: 500px;" alt="Квантова та класична обчислювальна технологія">
      
      <details>
        <summary>Прокляття розмірності</summary>
        <p>У класичному ML розмірність даних (n) веде до O(2ⁿ) обчислень для вичерпного пошуку. QML використовує квантові ядра, що дозволяють оцінити багатовимірні простори в O(log n), зменшуючи час обробки експоненціально. Джерело: <a href="https://pennylane.ai/qml/demos/" target="_blank">PennyLane QML Demos</a>.</p>
      </details>
    </section>

    <section id="section2" class="section"  style="background-color: #A6B8D3; padding: 20px; margin: 20px 0; border-radius: 10px; animation: fadeInSection 1s ease-in;">
      <h2 style="color: #0a041d; font-weight: 700; font-size: 35px;">Теоретичні основи: як квантовий світ підсилює AI</h2>
      <p style="line-height: 1.6; font-family: 'Cardo', serif; font-size: 31px; color: #271c2b; animation: colorShiftCardo 5s infinite alternate; text-align: justify;">Квантове машинне навчання (QML) – це не просто "квантовий тюнінг" класичного AI, а нова парадигма, що використовує принципи суперпозиції, заплутаність та інтерференцію. 
        Уявіть нейронну мережу, де кожен нейрон може бути в тисячах станів одночасно: це кубіт у суперпозиції, що дозволяє обробляти всі можливі комбінації даних паралельно. 
        <br><br>Основний <span style="font-weight: bold;  color: rgb(56, 28, 28);">інструмент QML – квантові схеми (quantum circuits), які замінюють класичні шари нейронних мереж.</span> Наприклад, <span class="code-trigger" data-code-id="quantum-circuit">параметризовані квантові схеми</span> (PQC) – це аналог ваг у нейронній мережі, але вони кодують дані в квантових станах, дозволяючи створювати складні нелінійні відображення, недоступні класичним моделям. 
       
       <br> <p style="line-height: 1.6; font-family: 'Cardo', serif; font-size: 24px; color: #271c2b; animation: colorShiftCardo 5s infinite alternate; text-align: justify; font-weight: 800; font-style: italic;"> Qiskit надає інструменти у своїй бібліотеці машинного навчання Qiskit для побудови та роботи з квантовими нейронними мережами (QNN). Ось приклади коду, що ілюструють ключові компоненти та базову реалізацію 
          QNN:
        <br> <span style="line-height: 1.6; font-family: 'Cardo', serif; font-size: 25px; color: #0a010e; animation: colorShiftCardo 5s infinite alternate; text-align: justify; font-weight: 800; font-style: italic;">1. Basic Parameterized Quantum Circuit (PQC) as a building block:
        
        <pre style="font-size: 23px; font-weight: 800; color:#003366;"><code>
          theta = ParameterVector('θ', length=2)
          qc = QuantumCircuit(2)
          qc.ry(theta[0], 0)  # Rotation-Y gate on qubit 0 with parameter theta[0]
          qc.cry(theta[1], 0, 1) # Controlled Rotation-Y gate on qubit 1 controlled by qubit 0
          print(qc.draw())
          </code></pre>

        </span>

          <br> <span style="line-height: 1.6; font-family: 'Cardo', serif; font-size: 25px; color: #0a010e; animation: colorShiftCardo 5s infinite alternate; text-align: justify; font-weight: 800; font-style: italic;">2. Defining a Quantum Neural Network (QNN) using Qiskit Machine Learning:
          This example demonstrates creating a SamplerQNN, which is based on the measurement outcomes (samples) of a quantum circuit: </span>

        <pre style="font-size: 23px; font-weight: 800; color:#003366;"><code>
          import numpy as np
          from qiskit.circuit.library import ZZFeatureMap, RealAmplitudes
          from qiskit_machine_learning.neural_networks import SamplerQNN
          from qiskit.primitives import Sampler
          
          # Define a feature map to encode classical data into quantum states
          feature_map = ZZFeatureMap(feature_dimension=2, reps=1)
          
          # Define a variational ansatz (parameterized quantum circuit)
          ansatz = RealAmplitudes(num_qubits=2, reps=1)
          
          # Combine feature map and ansatz
          qc_qnn = feature_map.compose(ansatz)
          
          # Create a SamplerQNN
          sampler = Sampler() # Use the default Sampler primitive
          qnn = SamplerQNN(circuit=qc_qnn, sampler=sampler, input_params=feature_map.parameters, weight_params=ansatz.parameters)
          
          # Example usage:
          input_data = np.array([0.5, 0.2])
          weights = np.random.rand(ansatz.num_parameters)
          output = qnn.forward(input_data, weights)
          print(f"QNN output for input {input_data} and weights {weights}: {output}")
        </code></pre>
    
        
     <br> <span style="line-height: 1.6; font-family: 'Cardo', serif; font-size: 25px; color: #0a010e; animation: colorShiftCardo 5s infinite alternate; text-align: justify; font-weight: 800; font-style: italic;">3. Training a QNN for a simple classification task:
        This example outlines the structure for training a QNN within a classification context, often involving classical optimization:</span>

        <pre style="font-size: 23px; font-weight: 800; color:#003366;"><code>
          import numpy as np
          from qiskit.circuit.library import ZZFeatureMap, RealAmplitudes
          from qiskit_machine_learning.neural_networks import SamplerQNN
          from qiskit.primitives import Sampler
          from qiskit.algorithms.optimizers import COBYLA
          
          # ... (feature_map, ansatz, qc_qnn, sampler, qnn as defined above) ...
          
          # Define a simple dataset
          X_train = np.array([[0.1, 0.9], [0.8, 0.2]])
          y_train = np.array([0, 1]) # Binary labels
          
          # Define a loss function
          def loss_function(weights):
              predictions = []
              for x_in in X_train:
                  # Assuming QNN output is a probability for class 1
                  # and we use 1-output for class 0
                  output_prob = qnn.forward(x_in, weights)[0]
                  predictions.append(output_prob)
          
              # Simple mean squared error loss
              loss = np.mean([(y_true - pred)**2 for y_true, pred in zip(y_train, predictions)])
              return loss
          
          # Initialize weights randomly
          initial_weights = np.random.rand(ansatz.num_parameters)
          
          # Use a classical optimizer
          optimizer = COBYLA(maxiter=100)
          
          # Train the QNN
          optimal_weights, min_loss, _ = optimizer.minimize(fun=loss_function, x0=initial_weights)
          
          print(f"Optimal weights: {optimal_weights}")
          print(f"Minimum loss: {min_loss}")
        </code></pre>
      
        </p>

        <p style="line-height: 1.6; font-family: 'Cardo', serif; font-size: 25px; color: #0a010e; animation: colorShiftCardo 5s infinite alternate; text-align: left; font-weight: 800; font-style: italic; text-align: justify;">  Звичайно, це дуже спрощений зразок коду створення QNN (квантової нейромережі), з використанням квантових схем (quantum circuits); <br>в другому фрагменті кода
          ми вже визначаємо квантову нейромережу (QNN) використовуючи бібліотеку мови Python - numpy та фреймворк qiskit, а саме:  qiskit.circuit.library, qiskit_machine_learning.neural_networks, qiskit primitives
          <br>В третьому прикладі - тренування квантової мережі (QNN) для вирішення задачі простої класифікації.</p>
                     
          <p style="line-height: 1.6; font-family: 'Cardo', serif; font-size: 31px; color: #271c2b; animation: colorShiftCardo 5s infinite alternate; text-align: justify; ">  
       <br><span style="font-weight: bold;  color: rgb(56, 28, 28)
        ;">Заплутаність дозволяє моделям "бачити" кореляції між даними,</span> які ігноруються класичними алгоритмами, подібно до того, як дві частинки, розділені галактиками, синхронно реагують. 
        <br><span style="font-weight: bold;  color: rgb(56, 28, 28);">Інтерференція підсилює правильні рішення,</span> пригнічуючи помилкові, як хвилі, що створюють гармонію в океані хаосу. 
        <br><br><span style="font-weight: bold;  color: rgb(56, 28, 28);">У 2025 році QML використовує гібридні системи: класичні алгоритми (наприклад, TensorFlow) оптимізують параметри квантових схем,</span> а квантові ядра (quantum kernels) оцінюють відстані в багатовимірних просторах. 
        <br><br>Це дозволяє, наприклад, класифікувати молекулярні структури для drug discovery у 10 разів швидше, ніж класичні SVM. <span style="font-weight: bold;  color: rgb(56, 28, 28);">Однак обмеження – декогеренція та потреба в error correction (QECC) – роблять гібридний підхід критичним.</span></p>      <div id="quantum-circuit-code" class="code-block" style="display: none;">
        <pre style="font-size: 23px; font-weight: 800; color:#003366;">
import pennylane as qml
dev = qml.device('default.qubit', wires=2)
@qml.qnode(dev)
def circuit(params):
    qml.RX(params[0], wires=0)
    qml.RY(params[1], wires=1)
    qml.CNOT(wires=[0, 1])
    return qml.expval(qml.PauliZ(0))
        </pre>
      </p>
      </div>
      
    </section>

    <section id="section3" class="section"  style="background-color: #A6B8D3; padding: 20px; margin: 20px 0; border-radius: 10px; animation: fadeInSection 1s ease-in;">
      <h2 style="color: #0a041d; font-weight: 700; font-size: 35px;">Гібридні системи: cинергія класичного та квантового AI</h2>
      <p style="line-height: 1.6; font-family: 'Cardo', serif; font-size: 31px; color: #271c2b; animation: colorShiftCardo 5s infinite alternate; text-align: justify;">Гібридні QML системи – це як оркестр, де класичні інструменти (CPU/GPU) грають у парі з квантовими (QPU). 
        У 2025 році, коли кількість кубітів обмежена (100–1000, MIT), гібридний підхід є основою QML. 
        <br><br>Класичні алгоритми, такі як TensorFlow чи PyTorch, використовуються для оптимізації параметрів квантових схем, тоді як QPU виконують обчислення, що потребують суперпозиції чи заплутаністі.
        <br><br>  Наприклад, у <span class="code-trigger" data-code-id="hybrid-qsvm">QSVM</span> (Quantum Support Vector Machine) квантовий комп’ютер обчислює ядро (kernel), яке оцінює відстані між точками даних у багатовимірному просторі, 
         а класичний оптимізатор (наприклад, SGD) налаштовує модель. 
         <br><br> Це дозволяє обробляти датасети з експоненціальною розмірністю, наприклад, для прогнозування фінансових ринків чи аналізу геномних даних. 
         <br><br> Парадокс: <span style="font-weight: bold;  color: rgb(56, 28, 28);">квантовий комп’ютер – це "геній хаосу", але потребує класичного "диригента" для стабільності.</span> 
         <br><br> У 2025 році NVIDIA та Quantinuum <span style="font-weight: bold;  color: rgb(56, 28, 28); text-decoration: underline;">досягли 50-кратного прискорення в ML-задачах, таких як класифікація зображень, завдяки гібридним системам.</span>
         <br> Обмеження – висока чутливість до декогеренції та потреба в QECC, що збільшує overhead (49 фізичних кубітів на 1 логічний у surface code).
         <br><br> Проте гібридний підхід дозволяє використовувати сучасні квантові процесори (<span style="font-weight: bold;  color: rgb(56, 28, 28);">Google Willow, IBM Loon)</span> для практичних задач, як-от оптимізація логістики чи моделювання хімічних реакцій.</p>
      <div id="hybrid-qsvm-code" class="code-block" style="display: none;">
        <pre style="font-size: 23px; font-weight: 800; color:#003366;">
import pennylane as qml
from pennylane import numpy as np
dev = qml.device('default.qubit', wires=4)
@qml.qnode(dev)
def kernel_circuit(x1, x2, params):
    qml.AngleEmbedding(x1, wires=range(4))
    qml.adjoint(qml.AngleEmbedding)(x2, wires=range(4))
    return qml.probs(wires=range(4))
        </pre>
      </div>
      
    </section>

    <section id="section4" class="section"  style="background-color: #A6B8D3; padding: 20px; margin: 20px 0; border-radius: 10px; animation: fadeInSection 1s ease-in;">
      <h2 style="color: #0a041d; font-weight: 700; font-size: 35px;">Популярні фреймворки: інструменти для QML</h2>
      <p style="line-height: 1.6; font-family: 'Cardo', serif; font-size: 31px; color: #271c2b; animation: colorShiftCardo 5s infinite alternate; text-align: justify;">У 2025 році <span style="font-weight: bold;  color: rgb(61, 9, 9);"> QML – це екосистема фреймворків, що поєднують квантові та класичні</span> обчислення. 
        Уявіть їх як космічні кораблі, що дозволяють подорожувати між мікросвітом кубітів і макросвітом даних.
       <p style="color: #eed8d8; font-size: 1.1em; font-size: 25px; text-align: justify; font-weight: 600; font-style: italic;">
       <ol style="line-height: 1.6; font-family: 'Cardo', serif; font-size: 31px; color: #271c2b; animation: colorShiftCardo 5s infinite alternate; text-align: justify;">
        <span style="font-weight: bold;  color: rgb(61, 9, 9);"> Основні гравці:</span>
         <li> <span style="font-weight: bold;  color: rgb(61, 9, 9);"> PennyLane (гібридні схеми, інтеграція з PyTorch/TensorFlow)</span> – лідер завдяки простоті: він дозволяє створювати параметризовані квантові схеми, які інтегруються з класичними ML-фреймворками, подібно до того, 
          як GPS направляє корабель через бурхливі хвилі; </li>
         <li><span style="font-weight: bold;  color: rgb(61, 9, 9);"> Qiskit (IBM, для superconducting кубітів)</span> - пропонує інструменти для роботи з реальними квантовими процесорами IBM, включаючи error mitigation;</li> 
         <li><span style="font-weight: bold;  color: rgb(61, 9, 9);">Cirq (Google, оптимізований для Willow)</span> - фокусується на оптимізації схем для Google Willow, з підтримкою surface code;</li> 
         <li><span style="font-weight: bold;  color: rgb(61, 9, 9);">TensorFlow Quantum (TFQ, для масштабних ML-задач)</span> - – це міст до великих нейронних мереж, де квантові ядра додають "суперпозицію" до класичних моделей. Наприклад, у задачі класифікації 
          геномних даних PennyLane може зменшити час навчання з годин до хвилин завдяки квантовим ядрам.</li> 
                            
       </ol>  
       <p style="line-height: 1.6; font-family: 'Cardo', serif; font-size: 31px; color: #271c2b; animation: colorShiftCardo 5s infinite alternate; text-align: justify;">Парадокс: ці фреймворки – класичні за інтерфейсом, але квантові за суттю, що робить їх доступними для програмістів без PhD з фізики.</p>
       <p style="line-height: 1.6; font-family: 'Cardo', serif; font-size: 31px; color: #271c2b; animation: colorShiftCardo 5s infinite alternate; text-align: justify;">У 2025 році 60% QML-досліджень використовують PennyLane через його гнучкість (Moody’s).</p>
       
      <div id="pennylane-code" class="code-block" style="display: none;">
        <pre>
import pennylane as qml
from pennylane import numpy as np
dev = qml.device('default.qubit', wires=2)
@qml.qnode(dev)
def circuit(x, weights):
    qml.AngleEmbedding(x, wires=range(2))
    for i in range(2):
        qml.RX(weights[i, 0], wires=i)
        qml.RY(weights[i, 1], wires=i)
    qml.CNOT(wires=[0, 1])
    return qml.expval(qml.PauliZ(0))
weights = np.random.random((2, 2))
        </pre>
      </div>
      
      <table style="width: 100%; border-collapse: collapse; margin: 20px 0; color: #ffffff;">
        <thead>
          <tr style="background: #003366;">
            <th style="padding: 10px; border: 1px solid #4a90e2;">Фреймворк</th>
            <th style="padding: 10px; border: 1px solid #4a90e2;">Розробник</th>
            <th style="padding: 10px; border: 1px solid #4a90e2;">Особливості</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td style="padding: 10px; border: 1px solid #4a90e2;">PennyLane</td>
            <td style="padding: 10px; border: 1px solid #4a90e2;">Xanadu</td>
            <td style="padding: 10px; border: 1px solid #4a90e2;">Гібридні схеми, PyTorch/TensorFlow</td>
          </tr>
          <tr>
            <td style="padding: 10px; border: 1px solid #4a90e2;">Qiskit</td>
            <td style="padding: 10px; border: 1px solid #4a90e2;">IBM</td>
            <td style="padding: 10px; border: 1px solid #4a90e2;">Error mitigation, superconducting</td>
          </tr>
          <tr>
            <td style="padding: 10px; border: 1px solid #4a90e2;">Cirq</td>
            <td style="padding: 10px; border: 1px solid #4a90e2;">Google</td>
            <td style="padding: 10px; border: 1px solid #4a90e2;">Оптимізація для Willow</td>
          </tr>
        </tbody>
      </table>
    </section>

    <section id="section5" class="section" style="background-color: #A6B8D3; padding: 20px; margin: 20px 0; border-radius: 10px; animation: fadeInSection 1s ease-in;">
      <h2 style="color: #0a041d; font-weight: 700; font-size: 35px;">QSVM у дії: Класифікація з квантовими ядрами</h2>
      
      <p style="line-height: 1.6; font-family: 'Cardo', serif; font-size: 31px; color: #271c2b; animation: colorShiftCardo 5s infinite alternate; text-align: justify;">Quantum Support Vector Machine (QSVM) – це як телескоп, що дозволяє бачити зірки в багатовимірному просторі даних. 
        У класичному SVM ядро (kernel) обчислює відстані між точками даних, але в багатовимірних датасетах (наприклад, геномні послідовності) це займає O(n²) часу. 
        <br><br>QSVM використовує квантові ядра, які кодують дані в суперпозицію, дозволяючи оцінити відстані в O(log n). 
        <br><br>Уявіть: замість того, щоб обчислювати кожну пару точок, квантовий комп’ютер "відчуває" весь простір одразу, як океанська течія, що несе інформацію про всі глибини. 
        <br><br> У 2025 році QSVM застосовується в drug discovery для класифікації молекул за їхньою активністю, досягаючи точності 95% проти 80% для класичного SVM (NVIDIA GTC).
         Наприклад, Quantinuum H2 використовує QSVM для аналізу геномних даних, зменшуючи час обробки з 10 годин до 12 хвилин. 
         <br> <br>Код QSVM у PennyLane дозволяє легко експериментувати: дані кодуються в квантові стани через AngleEmbedding, а ядро обчислюється через вимірювання ймовірностей. 
         <br> <br>Обмеження – чутливість до шуму, що вимагає QECC, і потреба в гібридних системах для оптимізації.</p>
      <div id="qsvm-code" class="code-block" style="display: none;">
        <pre>
import pennylane as qml
from pennylane import numpy as np
dev = qml.device('default.qubit', wires=4)
@qml.qnode(dev)
def quantum_kernel(x1, x2):
    qml.AngleEmbedding(x1, wires=range(4))
    qml.adjoint(qml.AngleEmbedding)(x2, wires=range(4))
    return qml.probs(wires=range(4))
from sklearn.svm import SVC
svm = SVC(kernel=lambda x1, x2: quantum_kernel(x1, x2)[0])
        </pre>
      </div>
      
    </section>

    <section id="section6" class="section" style="background-color: #A6B8D3; padding: 20px; margin: 20px 0; border-radius: 10px; animation: fadeInSection 1s ease-in;">
      <h2 style="color: #0a041d; font-weight: 700; font-size: 35px;">QGANs: Генерація даних у квантовому стилі</h2>
      <p style="line-height: 1.6; font-family: 'Cardo', serif; font-size: 31px; color: #271c2b; animation: colorShiftCardo 5s infinite alternate; text-align: justify;">Quantum Generative Adversarial Networks (QGANs) – це як художник, що малює картини в усіх можливих стилях одночасно.
         У класичних GANs генератор і дискримінатор змагаються, щоб створювати реалістичні дані, але для великих датасетів (наприклад, зображень чи молекул) це потребує величезних ресурсів.
         <br><br> QGANs використовують квантові схеми для генерації даних у суперпозиції, дозволяючи моделювати складні розподіли з меншою кількістю параметрів. 
         <br><br>Уявіть: замість того, щоб малювати кожен піксель окремо, QGAN "уявляє" всю картину одразу, використовуючи заплутаність для створення корельованих структур.
         <br><br> У 2025 році QGANs застосовуються в drug discovery для генерації нових молекулярних структур, досягаючи 30% вищої точності порівняно з класичними GANs (Quantum Insider). Наприклад, PennyLane дозволяє створювати <span class="code-trigger" data-code-id="qgan">QGAN</span>, де генератор – це квантова схема, а дискримінатор – класична нейронна мережа. Обмеження: декогеренція може спотворити згенеровані дані, а навчання QGANs вимагає гібридних систем із QECC. Проте потенціал величезний: від генерації синтетичних даних для AI до моделювання фінансових ринків.</p>
      <div id="qgan-code" class="code-block" style="display: none;">
        <pre>
import pennylane as qml
from pennylane import numpy as np
dev = qml.device('default.qubit', wires=3)
@qml.qnode(dev)
def generator_circuit(params):
    for i in range(3):
        qml.RX(params[i], wires=i)
        qml.RY(params[i + 3], wires=i)
    qml.CNOT(wires=[0, 1])
    qml.CNOT(wires=[1, 2])
    return qml.probs(wires=range(3))
        </pre>
      </div>
      
    </section>

    <section id="section7" class="section" style="background-color: #A6B8D3; padding: 20px; margin: 20px 0; border-radius: 10px; animation: fadeInSection 1s ease-in;">
      <h2 style="color: #0a041d; font-weight: 700; font-size: 35px;">Тренди 2025: QML на межі реальності</h2>
      <p style="line-height: 1.6; font-family: 'Cardo', serif; font-size: 31px; color: #271c2b; animation: colorShiftCardo 5s infinite alternate; text-align: justify;">У 2025 році QML переживає бум: інвестиції в сектор зросли на 40% (Moody’s), а фокус змістився на data-scarce задачі, де традиційний ML слабкий.
          <br><br>NVIDIA та Quantinuum досягли 50-кратного прискорення в задачах класифікації та генерації даних, наприклад, у моделюванні білків для healthcare. 
          <br><br>Google Willow інтегрує QML із surface code, забезпечуючи стійкість до шуму, тоді як IBM Loon фокусується на гібридних системах для фінансових прогнозів. 
          <br><br> QML ще не замінив класичний AI, але вже революціонізує нішеві задачі, як-от оптимізація логістики (DHL, 2025) чи аналіз медичних зображень.
         
        <br>Обмеження – висока вартість доступу до квантових процесорів і потреба в QECC – компенсуються хмарними платформами, як IBM Quantum Experience, що роблять QML доступним для розробників.</p>
     
    </section>

    <section id="section8" class="section" style="background-color: #A6B8D3; padding: 20px; margin: 20px 0; border-radius: 10px; animation: fadeInSection 1s ease-in;">
      <h2 style="color: #0a041d; font-weight: 700; font-size: 35px;">Застосування в NLP: квантовий підхід до обробки природної мови</h2>
      <p style="line-height: 1.6; font-family: 'Cardo', serif; font-size: 31px; color: #271c2b; animation: colorShiftCardo 5s infinite alternate; text-align: justify;">Обробка природної мови (NLP) – це як розшифровка космічних сигналів: тексти, як зоряне небо, ховають складні патерни.
         Класичні моделі, як BERT чи GPT, потребують мільярдів параметрів, щоб "зрозуміти" мову, але QML використовує квантові ядра для аналізу семантичних зв’язків у багатовимірних просторах. 
         
         <br> У 2025 році QML застосовується в NLP для задач, як-от sentiment analysis чи переклад, досягаючи 20% вищої точності в data-scarce сценаріях (Quantum Insider). 
         <br> Наприклад, QSVM із квантовим ядром може класифікувати твіти за емоційним забарвленням швидше, ніж класичний SVM, завдяки паралельній обробці.
         <br>   PennyLane та Cirq дозволяють створювати квантові моделі NLP, інтегровані з TensorFlow. 
         <br> У майбутньому QML може революціонізувати чат-боти, роблячи їх "інтуїтивно" розумними.</p>
      
    </section>

    <section id="section9" class="section" style="background-color: #A6B8D3; padding: 20px; margin: 20px 0; border-radius: 10px; animation: fadeInSection 1s ease-in;">
      <h2 style="color: #0a041d; font-weight: 700; font-size: 35px;">Майбутнє QML: Куди веде мікросвіт</h2>
      <p style="line-height: 1.6; font-family: 'Cardo', serif; font-size: 31px; color: #271c2b; animation: colorShiftCardo 5s infinite alternate; text-align: justify;">Майбутнє QML – це як космічна подорож до нових галактик: у 2025 році ми лише на старті, але потенціал величезний. 
        <br><p style="line-height: 1.6; font-family: 'Cardo', serif; font-size: 31px; color: #271c2b; animation: colorShiftCardo 5s infinite alternate; text-align: justify;">За прогнозами Moody’s, до 2035 року QML може зайняти 20% ринку AI, особливо в healthcare (моделювання білків), фінансах (оптимізація портфелів) та логістиці (маршрутизація).</p> 
        <br> <p style="line-height: 1.6; font-family: 'Cardo', serif; font-size: 31px; color: #271c2b; animation: colorShiftCardo 5s infinite alternate; text-align: justify;">Уявіть квантову нейронну мережу, яка не просто вчиться, а "відчуває" дані, використовуючи суперпозицію для експоненціального прискорення. </p>
        <br><p style="line-height: 1.6; font-family: 'Cardo', serif; font-size: 31px; color: #271c2b; animation: colorShiftCardo 5s infinite alternate; text-align: justify;">Хоча сучасні квантові комп’ютери обмежені 1000 кубітів, гібридні системи дозволяють досягати quantum advantage уже сьогодні. </p>
        <p style="line-height: 1.6; font-family: 'Cardo', serif; font-size: 31px; color: #271c2b; animation: colorShiftCardo 5s infinite alternate; text-align: justify;">Наприклад, IBM планує до 2030 року запустити fault-tolerant QML-системи з мільйонами логічних кубітів, що зробить QML основою для AI в реальному часі.</p> 
        <br> <p style="line-height: 1.6; font-family: 'Cardo', serif; font-size: 31px; color: #271c2b; animation: colorShiftCardo 5s infinite alternate; text-align: justify;"> Розробники можуть почати з <span class="code-trigger" data-code-id="qml-future">PennyLane чи Qiskit</span>, експериментуючи з простими моделями, як QSVM чи QGANs. </p>
        <br> <p style="line-height: 1.6; font-family: 'Cardo', serif; font-size: 31px; color: #271c2b; animation: colorShiftCardo 5s infinite alternate; text-align: justify;">Виклик – інтеграція з класичними системами та подолання декогеренції – буде вирішено через прогрес у QECC та хмарних платформах. Почніть свою подорож у QML уже сьогодні, і, 
          можливо, ви створите наступний прорив у AI!</p>
     
     
    </section>
  </div>

  <!-- Пересувна кнопка контекстного меню -->
  <button id="context-btn">☰</button>
  <!-- Кнопка для відображення заголовків -->
  <button id="toc-btn">📑 Зміст</button>
</div>

<!-- Вбудовані стилі CSS -->
<style>
  .container {
    position: relative;
    min-height: 100vh;
    background: radial-gradient(circle, #e2e5e7 0%, #e2e5e7 100%);
   
    padding: 20px;
    overflow-x: hidden;
    font-family: 'Arial', sans-serif;
    width: 1300px;
  }

  .space-bg {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-image: url('https://upload.wikimedia.org/wikipedia/commons/thumb/6/62/Star-forming_region_S106.jpg/1024px-Star-forming_region_S106.jpg');
    background-size: cover;
    background-position: center;
    opacity: 0.65;
    z-index: 1;
  }
  
  .sidebar {
    position: fixed;
    top: 0;
    left: 0;
    width: 310px;
    height: 100vh;
    padding: 20px;
    z-index: 999;
    overflow-y: auto;
    
    background-color: #b3c6ca;
    transition: transform 0.3s ease;
  }

  .sidebar h3 {
    color: #2c2104;
    text-align: center;
    margin-bottom: 31px;
    font-size: 31px;
    
  }

  .sidebar ul {
    list-style: none;
    padding: 0;
  }

  .nav-button {
    display: block;
    padding: 14px;
    margin: 10px 0;
    background: linear-gradient(45deg, #7eade4, #b3c6ca);
    color: #211255; 
     text-align: left; font-style: italic; font-weight: 800;
    
    text-decoration: none;
    border-radius: 10px;
    transition: transform 0.3s, box-shadow 0.3s;
    font-weight: bold;
    font-size: 23px;
    
  }

  .nav-button:hover {
    transform: scale(1.06);
    box-shadow: 0 0 12px rgba(0, 255, 255, 0.9);
  }

  .content {
    margin-left: 210px;
    margin-right: 10px;
    padding: 30px;
    position: relative;
    z-index: 2;
    width: 1290px;
  }

  .welcome-text {
    text-align: center;
    color: #00d4ff;
    
    animation: fadeIn 2s ease-in-out;
  }

  .welcome-text h1 {
    font-size: 3em;
    margin: 0;
    font-family: 'Georgia', serif;
  }

  .welcome-text p {
    font-size: 1.3em;
    margin: 15px 0;
  }

  .section {
    background-color: #A6B8D3;
    
    padding: 25px;
    margin: 25px 0;
    border-radius: 12px;
    width: 980px;
    color: #ffffff;
    animation: fadeInSection 1.2s ease-in;
    box-shadow: 0 0 12px rgba(0, 255, 255, 0.4);
    margin-left: 10px;
  }

  .section h2 {
    color: #4a90e2;
    font-size: 2em;
    font-family: 'Georgia', serif;
  }

  .section p {
    font-size: 1.15em;
    line-height: 1.7;
  }

  .section table {
    width: 100%;
    border-collapse: collapse;
    margin: 20px 0;
  }

  .section th, .section td {
    padding: 12px;
    border: 1px solid #4a90e2;
    text-align: left;
  }

  .section th {
    background: #003366;
    color: #ffffff;
  }

  .section a {
    color: #00d4ff;
    text-decoration: none;
    transition: color 0.3s;
  }

  .section a:hover {
    color: #b8860b;
    text-decoration: underline;
  }

  .code-trigger {
    color: #00d4ff;
    cursor: pointer;
    text-decoration: underline;
  }

  .code-trigger:hover {
    color: #b8860b;
  }

  .code-block {
    background: #002244;
    padding: 15px;
    border-radius: 8px;
    margin: 10px 0;
    font-size: 0.9em;
    color: #ffffff;
    border: 1px solid #4a90e2;
  }

  .simulation-box {
    background: linear-gradient(45deg, #003366, #001233);
    padding: 25px;
    border-radius: 12px;
    margin: 25px 0;
    text-align: center;
    box-shadow: 0 0 12px rgba(0, 255, 255, 0.6);
  }

  .simulation-box h3 {
    color: #b8860b;
    margin-bottom: 15px;
    font-size: 1.5em;
  }

  #simulate-qml-btn {
    background: linear-gradient(45deg, #4a90e2, #00d4ff);
    border: none;
    padding: 12px 25px;
    color: #ffffff;
    font-weight: bold;
    border-radius: 8px;
    cursor: pointer;
    transition: transform 0.3s, box-shadow 0.3s;
  }

  #simulate-qml-btn:hover {
    transform: scale(1.06);
    box-shadow: 0 0 12px rgba(0, 255, 255, 0.9);
  }

  #qml-simulation-result {
    margin-top: 15px;
    font-size: 1.3em;
    color: #00d4ff;
    text-shadow: 0 0 6px #00d4ff;
  }

  .action-buttons {
    display: flex;
    justify-content: center;
    gap: 25px;
    margin: 25px 0;
  }

  .action-btn {
    background: linear-gradient(45deg, #4a90e2, #00d4ff);
    padding: 14px 25px;
    color: #ffffff;
    text-decoration: none;
    border-radius: 10px;
    font-weight: bold;
    font-size: 15px;
    transition: transform 0.3s, box-shadow 0.3s;
  }

  .action-btn:hover {
    transform: scale(1.06);
    box-shadow: 0 0 12px rgba(0, 255, 255, 0.9);
  }

  details {
    margin: 15px 0;
    color: #ffffff;
  }

  summary {
    color: #4a90e2;
    cursor: pointer;
    font-weight: bold;
    font-size: 1.2em;
  }

  #context-btn, #toc-btn {
    position: fixed;
    bottom: 25px;
    right: 25px;
    width: 45px;
    height: 45px;
    background: linear-gradient(45deg, #4a90e2, #00d4ff);
    color: #ffffff;
    border: none;
    border-radius: 50%;
    cursor: move;
    font-size: 22px;
    z-index: 1000;
    box-shadow: 0 0 12px rgba(0, 255, 255, 0.6);
    animation: pulseBtn 2s infinite;
  }

  #toc-btn {
    bottom: 80px;
    font-size: 20px;
  }

  #context-btn:hover, #toc-btn:hover {
    transform: scale(1.1);
  }

  @keyframes twinkle {
    0%, 100% { opacity: 0.35; }
    50% { opacity: 0.55; }
  }

  @keyframes fadeIn {
    0% { opacity: 0; }
    100% { opacity: 1; }
  }

  @keyframes fadeInSection {
    0% { opacity: 0; transform: translateY(25px); }
    100% { opacity: 1; transform: translateY(0); }
  }

  @keyframes pulseBtn {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.06); }
  }

  @media (max-width: 768px) {
    .sidebar {
      width: 160px;
    }
    .content {
      margin-left: 180px;
      padding: 20px;
    }
    .welcome-text h1 {
      font-size: 2.2em;
    }
    .welcome-text p {
      font-size: 1.1em;
    }
    .section h2 {
      font-size: 1.6em;
    }
    .section p {
      font-size: 1em;
    }
    .nav-button, .action-btn {
      font-size: 13px;
      padding: 10px;
    }
    .simulation-box h3 {
      font-size: 1.3em;
    }
    #simulate-qml-btn {
      padding: 10px 20px;
    }
    #context-btn, #toc-btn {
      width: 40px;
      height: 40px;
      font-size: 20px;
    }
  }
</style>

<!-- Вбудований JavaScript -->
<script>
  // Симуляція квантового ядра QSVM
  document.getElementById('simulate-qml-btn').addEventListener('click', () => {
    const accuracy = (Math.random() * (0.95 - 0.85) + 0.85).toFixed(2);
    document.getElementById('qml-simulation-result').textContent = `Точність класифікації: ${accuracy * 100}%`;
    document.getElementById('qml-simulation-result').style.animation = 'fadeIn 0.5s';
    setTimeout(() => {
      document.getElementById('qml-simulation-result').style.animation = '';
    }, 500);
  });

  // Плавна прокрутка для навігації бічної панелі
  document.querySelectorAll('.nav-button').forEach(link => {
    link.addEventListener('click', function(e) {
      e.preventDefault();
      const targetId = this.getAttribute('href').substring(1);
      const target = document.getElementById(targetId);
      target.scrollIntoView({ behavior: 'smooth' });
      document.querySelectorAll('.section').forEach(sec => sec.classList.remove('highlight'));
      target.classList.add('highlight');
      setTimeout(() => target.classList.remove('highlight'), 2000);
    });
  });

  // Показ коду при кліку на ключові слова
  document.querySelectorAll('.code-trigger').forEach(trigger => {
    trigger.addEventListener('click', () => {
      const codeId = trigger.getAttribute('data-code-id');
      const codeBlock = document.getElementById(`${codeId}-code`);
      codeBlock.style.display = codeBlock.style.display === 'none' ? 'block' : 'none';
    });
  });

  // Пересувна кнопка контекстного меню
  const contextBtn = document.getElementById('context-btn');
  contextBtn.addEventListener('mousedown', function(e) {
    e.preventDefault();
    let shiftX = e.clientX - contextBtn.getBoundingClientRect().left;
    let shiftY = e.clientY - contextBtn.getBoundingClientRect().top;

    function moveAt(pageX, pageY) {
      contextBtn.style.left = pageX - shiftX + 'px';
      contextBtn.style.top = pageY - shiftY + 'px';
    }

    function onMouseMove(e) {
      moveAt(e.pageX, e.pageY);
    }

    document.addEventListener('mousemove', onMouseMove);

    contextBtn.addEventListener('mouseup', function() {
      document.removeEventListener('mousemove', onMouseMove);
      contextBtn.onmouseup = null;
    });
  });

  contextBtn.ondragstart = function() {
    return false;
  };

  // Перемикання видимості бічної панелі
  contextBtn.addEventListener('click', () => {
    const sidebar = document.querySelector('.sidebar');
    sidebar.style.left = sidebar.style.left === '0px' ? '-240px' : '0px';
  });

  // Кнопка для відображення змісту
  const tocBtn = document.getElementById('toc-btn');
  tocBtn.addEventListener('click', () => {
    const toc = document.createElement('div');
    toc.style.position = 'fixed';
    toc.style.top = '50%';
    toc.style.left = '50%';
    toc.style.transform = 'translate(-50%, -50%)';
    toc.style.background = 'linear-gradient(45deg, #003366, #001233)';
    toc.style.padding = '20px';
    toc.style.borderRadius = '12px';
    toc.style.boxShadow = '0 0 12px rgba(0, 255, 255, 0.6)';
    toc.style.zIndex = '1001';
    toc.style.color = '#ffffff';
    toc.style.maxHeight = '80vh';
    toc.style.overflowY = 'auto';
    
    const tocList = document.createElement('ul');
    tocList.style.listStyle = 'none';
    tocList.style.padding = '0';
    document.querySelectorAll('.section h2').forEach((h2, index) => {
      const li = document.createElement('li');
      const a = document.createElement('a');
      a.textContent = h2.textContent;
      a.href = `#section${index + 1}`;
      a.style.color = '#00d4ff';
      a.style.textDecoration = 'none';
      a.style.display = 'block';
      a.style.padding = '10px';
      a.style.fontSize = '1.1em';
      a.addEventListener('click', (e) => {
        e.preventDefault();
        document.getElementById(`section${index + 1}`).scrollIntoView({ behavior: 'smooth' });
        toc.remove();
      });
      li.appendChild(a);
      tocList.appendChild(li);
    });
    
    const closeBtn = document.createElement('button');
    closeBtn.textContent = 'Закрити';
    closeBtn.style.background = 'linear-gradient(45deg, #4a90e2, #00d4ff)';
    closeBtn.style.border = 'none';
    closeBtn.style.padding = '10px';
    closeBtn.style.borderRadius = '8px';
    closeBtn.style.color = '#ffffff';
    closeBtn.style.marginTop = '15px';
    closeBtn.style.cursor = 'pointer';
    closeBtn.addEventListener('click', () => toc.remove());
    
    toc.appendChild(tocList);
    toc.appendChild(closeBtn);
    document.body.appendChild(toc);
  });

  // Додавання стилю для підсвічування
  const style = document.createElement('style');
  style.textContent = `
    .highlight {
      background: linear-gradient(45deg, #003366, #001233) !important;
      transform: scale(1.02) !important;
      transition: background 0.3s, transform 0.3s;
    }
  `;
  document.head.appendChild(style);
</script>

<p class="attribution">Зображення з Wikimedia Commons (Public Domain).</p>
{% endblock %}
</xaiArtifact>